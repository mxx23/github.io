<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2024-10-09养生</title>
    <link href="/2024/10/09/2024-10-09%E5%85%BB%E7%94%9F/"/>
    <url>/2024/10/09/2024-10-09%E5%85%BB%E7%94%9F/</url>
    
    <content type="html"><![CDATA[<p>　　前两天国庆假期结束，没办法再睡到中午才起床了，又恰巧看了一些网上的自律打假视频，虽然是打假，但是确实也引起了我的自律之心，打算早点睡早点起。于是定了5点20的闹钟，晚上十一点就入睡了，打算5点多起床打游戏（学习？不存在的）。结果没成想4点半就醒来了，而且还睡不着了，可能是因为之前一天睡到中午，在最近24小时内的睡眠时长达标了所以没那么困？于是就起床打游戏，先是把4399造梦西游每日必刷的给刷掉，然后打打台球。然后早上6点多洗个澡，洗完接着打游戏，8点出发上班。起得早果然还是会有种睡眠不足的感觉，不过倒是没有让我在上班时犯困。等到晚上回家后，倦意就来了，晚上10点就睡觉了。然后5点20的闹钟没能让我起床，6点20的叫醒了我。6点左右是个不错的起床时间，不会太早，又有一定的空余时间，无论是哪天心血来潮想出去晨跑，还是打游戏什么的都能抽出时间来。上班的路上，脑子里思绪纷飞。想起以前初一时候学校举办的文艺汇演，以前初一的时候看到一个初三的学姐们表演的《咏春》舞蹈节目，歌很好听，当然，她们的舞姿更是迷人。当时看学姐们感觉她们相比同龄人要显得成熟，有一种难以言明的魅力。现如今回想起依然觉得她们有一种成熟的魅力，而不会因为我已经长大而认为她们只是初三稚嫩的小妹妹，不过其实是因为我已经忘记了舞蹈的具体细节，只记得自己曾经的感受，于是只有这份感受较为清晰地保留在记忆里了。<br>　　写这篇博客时，已经晚上十一点半了，我要睡觉了，就写这么多吧。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 945 (Div. 2)</title>
    <link href="/2024/05/21/Codeforces-Round-945-Div-2/"/>
    <url>/2024/05/21/Codeforces-Round-945-Div-2/</url>
    
    <content type="html"><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://codeforces.com/contest/1973">Codeforces Round 945 (Div. 2)</a></p><h2 id="Problem-A-Chess-For-Three"><a href="#Problem-A-Chess-For-Three" class="headerlink" title="Problem A: Chess For Three"></a>Problem A: Chess For Three</h2><ul><li>时间限制：1秒</li><li>内存限制：256 MB</li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>　　三个人，两两可以进行游戏，游戏可以进行任意多局（可以是0）。每一局游戏结束时，胜方得2分，败方不得分，若平局，则各得1分。现在给定三人的最终得分 $p_1, p_2, p_3$ ，保证 $p_1 \le p_2 \le p_3$ ，问：最多可能平局了多少次？输出这个最大可能值。如果这个得分情况不可能存在，则输出-1。</p><ul><li><p>输入描述<br>　　第一行，一个正整数 $t (1\le t \le 500)$，表示接下来有 $t$ 组数据。<br>　　接下来 $t$ 行，每行三个非负整数 $p_1, p_2, p_3 (0\le p_1 \le p_2 \le p_3 \le 30)$，表示三人的最终得分。</p></li><li><p>输出描述<br>　　对于每组数据，输出一个可能的最大平局数，如果该组得分不合法，输出-1。</p></li></ul><h3 id="测试样例"><a href="#测试样例" class="headerlink" title="测试样例"></a>测试样例</h3><ul><li>输入<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs TEXT">7<br>0 0 0<br>0 1 1<br>1 1 1<br>1 1 2<br>3 3 3<br>3 4 5<br>1 1 10<br></code></pre></td></tr></table></figure></li><li>输出<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs TEXT">0<br>1<br>-1<br>2<br>-1<br>6<br>2<br></code></pre></td></tr></table></figure></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>　　假设三人的得分都是偶数，那么分数一定是合法的。如果三人中两人是奇数，一人是偶数，那么也是合法的，因为两个奇数得分的玩家可以平局一次，剩下的分数就都是偶数了。其他奇偶情况都不合法，直接输出-1即可。在数据合法的情况下，直接贪心。如果满足 $p_1 + p_2 \ge p_3$ ，那么全部都可以是平局，最终答案就是 $\frac{p_1+p_2+p_3}{2}$ 。如果不满足，答案就是 $p_1+p_2$ 。</p><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> p1 = <span class="hljs-number">0</span>, p2 = <span class="hljs-number">0</span>, p3 = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; p3;<br>    <span class="hljs-comment">// 奇数个数是奇数</span><br>    <span class="hljs-keyword">if</span> ((p1 &amp; <span class="hljs-number">1</span>) ^ (p2 &amp; <span class="hljs-number">1</span>) ^ (p3 &amp; <span class="hljs-number">1</span>))<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (p1 + p2 &gt;= p3)<br>    &#123;<br>        cout &lt;&lt; (p1 + p2 + p3) / <span class="hljs-number">2</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        cout &lt;&lt; p1 + p2 &lt;&lt; endl;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">1</span>;<br>    cin &gt;&gt; t;<br>    <span class="hljs-keyword">while</span> (t--)<br>    &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Problem-B-Cat-Fox-and-the-Lonely-Array"><a href="#Problem-B-Cat-Fox-and-the-Lonely-Array" class="headerlink" title="Problem B: Cat, Fox and the Lonely Array"></a>Problem B: Cat, Fox and the Lonely Array</h2><ul><li>时间限制：2秒</li><li>内存限制：256 MB</li></ul><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>　　定义一个数组 $A$ 的孤独值 $k$ 为满足某个条件的最小可能取值。条件：数组中任意连续 $k$ 个相邻元素的按位或(bitwise OR)结果相同。更数学化的表达为：<br>$$<br>\forall{i}\forall{j}(i,j \in [1,n-k+1] \cap \mathbb{Z}) \rightarrow a_i|a_{i+1}|…|a_{i+k-1} &#x3D; a_j|a_{j+1}|…|a_{j+k-1}$$ 其中 $\mathbb{Z}$ 为整数域。<br>　　显然，当 $k&#x3D;n$ 时满足条件，因为当 $k&#x3D;n$ 时，连续 $k$ 个相邻元素只有一种选取情况，即整个数组，故而只有一种计算结果。现在给定一个数组，请问它的孤独值是多少？</p><ul><li>输入描述<br>　　第一行，一个正整数 $t (1\le t\le 10^4)$，表示接下来有 $t$ 组数据。<br>　　每组数据包含两行，第一行，一个正整数 $n (1\le n\le 10^5)$，表示数组长度。<br>　　每组数据第二行， $n$ 个非负整数 $a_1,a_2,…,a_n(0\le a_i\le 2^{20})$，表示给定的数组。<br>　　数据保证所有组数的 $n$ 总和不超过 $10^5$。</li><li>输出描述<br>　　每一组数据输出一行，包含一个正整数，表示该组数据得到的孤独值。</li></ul><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ul><li>输入<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs TEXT">7<br>1<br>0<br>3<br>2 2 2<br>3<br>1 0 2<br>5<br>3 0 1 4 2<br>5<br>2 0 4 0 2<br>7<br>0 0 0 0 1 2 4<br>8<br>0 1 3 2 2 1 0 3<br></code></pre></td></tr></table></figure></li><li>输出<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs TEXT">1<br>1<br>3<br>4<br>4<br>7<br>3<br></code></pre></td></tr></table></figure></li></ul><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>　　当一个取值 $k$ 符合条件时，比 $k$ 更大的数值也一定符合条件，因此最外层可以用二分法来调整 $k$ 的取值。内部判断该取值是否符合条件时，可以用滑动窗口思想来处理，滑动窗口就是双指针的一种特殊情况，双指针的两个指针距离固定。我们可以先统计前 $k$ 个元素的二进制表示下各个位上有值的次数，比如 $1, 3, 4$ ，就是 $2^0$ 出现 $2$ 次， $2^1, 2^2$ 各出现 $1$ 次。在我们将窗口依次往后移动的时候，如果存在某个位的次数统计从 $0$ 变为 $1$ ，或者减少为 $0$ ，那么意味着当前窗口的按位或结果和最初的结果不一致，这个 $k$ 的取值就不符合条件。</p><h3 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> arr[<span class="hljs-number">100005</span>];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> bit_count[<span class="hljs-number">25</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; ++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">20</span>; ++j)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (arr[i] &amp; (<span class="hljs-number">1</span> &lt;&lt; j))<br>            &#123;<br>                bit_count[j]++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = k;<br>    <span class="hljs-keyword">while</span> (r &lt; n)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">20</span>; ++j)<br>        &#123;<br>            <span class="hljs-type">int</span> tmp = bit_count[j];<br>            <span class="hljs-keyword">if</span> (arr[l] &amp; (<span class="hljs-number">1</span> &lt;&lt; j))<br>            &#123;<br>                bit_count[j]--;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (arr[r + <span class="hljs-number">1</span>] &amp; (<span class="hljs-number">1</span> &lt;&lt; j))<br>            &#123;<br>                bit_count[j]++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> ((tmp == <span class="hljs-number">0</span>) != (bit_count[j] == <span class="hljs-number">0</span>))<br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        l++, r++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>    &#123;<br>        cin &gt;&gt; arr[i];<br>    &#125;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = n;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid))<br>        &#123;<br>            r = mid;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; r &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">1</span>;<br>    cin &gt;&gt; t;<br>    <span class="hljs-keyword">while</span> (t--)<br>    &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Problem-C-Cat-Fox-and-Double-Maximum"><a href="#Problem-C-Cat-Fox-and-Double-Maximum" class="headerlink" title="Problem C: Cat, Fox and Double Maximum"></a>Problem C: Cat, Fox and Double Maximum</h2><ul><li>时间限制：2秒</li><li>内存限制：256MB</li></ul><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>　　给定一个长度为偶数的排列 $P$ ，请构造一个长度和 $P$ 一致的排列 $P_2$ 使得二者每个位置上对应元素相加后得到的数组 $A$ 的局部最大元素的个数最多，如果有多种构造方案，请给出任意一种。<br>　　<strong>排列</strong> ：如果排列长度是 $n$ ，那么其中 $1 \sim n$ 每个值都出现且仅出现一次。<br>　　<strong>局部最大元素</strong> ：数组中严格大于相邻的左右两个元素值的元素，数组首部和尾部不作为局部最大元素。</p><ul><li><p>输入描述<br>　　第一行，一个正整数 $t(1\le t\le 10^4)$ ，表示接下来有 $t$ 组数据。<br>　　每组数据的第一行，一个正整数 $n(4\le n\le 10^5,且 n 是偶数)$，表示该组数据给定的排列长度。<br>　　每组数据的第二行，一个长度为 $n$ 的排列 $p_1, p_2, … , p_n$。<br>　　数据保证所有组的 $n$ 总和不超过 $10^5$ 。</p></li><li><p>输出描述<br>　　对于每组数据，输出一个长度和给定排列 $P$ 一致的排列 $P_2$ ，使得 $P$ 与 $P_2$ 对应位置元素相加后得到的数组具有最多的局部最大元素个数。</p></li></ul><h3 id="测试用例-1"><a href="#测试用例-1" class="headerlink" title="测试用例"></a>测试用例</h3><ul><li><p>输入</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs TEXT">4<br>4<br>1 2 3 4<br>4<br>4 3 1 2<br>6<br>6 5 1 4 2 3<br>8<br>1 2 4 5 7 6 8 3<br></code></pre></td></tr></table></figure></li><li><p>输出</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs TEXT">2 4 1 3<br>3 1 4 2<br>2 5 1 4 3 6<br>5 4 8 2 7 1 6 3<br></code></pre></td></tr></table></figure></li></ul><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>　　给定的排列长度 $n$ 是偶数，而首尾又不能算作局部最大元素，那么在最好的情况下，最终能得到的局部最大元素个数为 $\frac{n}{2} - 1$。给出的是排列，要构造的也是排列，最为均衡的情况就是我们可以让最终的每个元素值都等于 $n+1$ ，只不过这样是没有局部最大值的。所以要考虑一下能否将所有奇数位置的元素或者所有偶数位置的元素都再大一点，比如将所有偶数位置都凑成 $n+2$ ，奇数位置则小一点。不过有个元素比较特殊，那就是 $1$ ，因为最多能让它凑成 $n + 1$ 。因此，如果 $1$ 在偶数位，我们就凑奇数位，反之凑偶数位。这样就必然能够让 $\frac{n}{2}$ 个间隔开来的元素凑成 $n+2$ ，至于另外的 $\frac{n}{2}$ 个元素，它们总体上肯定是比之前均衡分配时要小上 $\frac{n}{2}$ ，但是如果将剩余的元素胡乱分配，也是有可能又不小心凑出个 $n + 2$ ，导致整个数组少那么一两个局部最大值。所以不能胡乱分配，应该让数值越小的元素分配越大的值。</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> p[<span class="hljs-number">100005</span>];<br><span class="hljs-type">int</span> p2[<span class="hljs-number">100005</span>];<br><span class="hljs-type">bool</span> used[<span class="hljs-number">100005</span>]; <span class="hljs-comment">// 该值是否已被分配？</span><br><span class="hljs-comment">// 该数据的 Right[index] 用于存储不小于 index 的最小的一个未被分配的值</span><br><span class="hljs-type">int</span> Right[<span class="hljs-number">100005</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">bool</span> one_in_odd = <span class="hljs-literal">false</span>;<br>    cin &gt;&gt; n;<br>    <span class="hljs-comment">// init</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>    &#123;<br>        p[i] = p2[i] = <span class="hljs-number">0</span>;<br>        used[i] = <span class="hljs-literal">false</span>;<br>        Right[i] = i;<br>    &#125;<br>    <span class="hljs-comment">// init end</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>    &#123;<br>        cin &gt;&gt; p[i];<br>        <span class="hljs-keyword">if</span> (p[i] != <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        one_in_odd = i % <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> + (one_in_odd ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>); i &lt;= n; i += <span class="hljs-number">2</span>)<br>    &#123;<br>        p2[i] = n + <span class="hljs-number">2</span> - p[i];<br>        used[p2[i]] = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; --i)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (used[i])<br>        &#123;<br>            Right[i] = Right[i + <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            Right[i] = i;<br>        &#125;<br>    &#125;<br>    priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; wait_index;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> + (one_in_odd ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>); i &lt;= n; i += <span class="hljs-number">2</span>)<br>    &#123;<br>        wait_index.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(p[i], i));<br>    &#125;<br>    <span class="hljs-type">int</span> value_unused = Right[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span> (!wait_index.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> node = wait_index.<span class="hljs-built_in">top</span>();<br>        wait_index.<span class="hljs-built_in">pop</span>();<br>        p2[node.second] = value_unused;<br>        value_unused = Right[value_unused + <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>    &#123;<br>        cout &lt;&lt; p2[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">1</span>;<br>    cin &gt;&gt; t;<br>    <span class="hljs-keyword">while</span> (t--)<br>    &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Problem-D-Cat-Fox-and-Maximum-Array-Split"><a href="#Problem-D-Cat-Fox-and-Maximum-Array-Split" class="headerlink" title="Problem D: Cat, Fox and Maximum Array Split"></a>Problem D: Cat, Fox and Maximum Array Split</h2><ul><li>时间限制：3秒</li><li>内存限制：256MB</li></ul><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>　　<strong>本题为交互题，输入数据不会一次性全部给出，而是通过用户程序的输出与测试程序进行交互，记得在输出内容后及时刷新输出缓冲区。</strong><br>　　假设有一个数组 $A &#x3D; [a_1, a_2, … , a_n]$ ，我们定义 $f(l,r) &#x3D; (r - l + 1) * \max\limits_{i&#x3D;l}^{r}{a_i}$，其中 $l \le r$ 。也就是位于数组位置 $[l, r]$ 中的最大值与位于该范围内的元素个数的积。<br>　　现在，A和你要玩一个小游戏。A拥有一个长度为 $n$ 的数组 $[a_1, a_2, …, a_n]$ 。 B 不知道数组的具体数值， A 只给出了两个正整数 $n, k$ 。其中， $n$ 代表数组的长度，$k$ 代表你需要将数组 $A_n$ 划分为 $k$ 段，使得每一段的 $f(l,r)$ 值都相等，即：<br>$$<br>f(1, r_1) &#x3D; f(r_1 + 1, r_2) &#x3D; … &#x3D; f(r_{k-1} + 1, n) &#x3D; m<br>$$　　同时，你还需要让这个 $m$ 尽可能大。当然，你不需要给出具体的划分方案，只需要给出这个 $m$ 的值。<br>　　你可以向 A 进行最多 $2n$ 次询问，每次询问时可以给出两个正整数 “x y” 询问数组中以 $x$ 为左界， 满足 $f(x, r) &#x3D; y$ 的最小 $r$ 。如果存在这样一个最小 $r$ 使得 $f(x, r) &#x3D; y$ ，那么 A 会给出 $r$ 的值，否则给出 $n + 1$ 。<br>　　如果你找到了最终答案 $m$ ，请给出该答案，若不存在合法的划分方式，请给出 $-1$ 。</p><h3 id="输入-输出描述"><a href="#输入-输出描述" class="headerlink" title="输入&#x2F;输出描述"></a>输入&#x2F;输出描述</h3><p>　　第一行，包含一个正整数 $t (1\le t \le 10^3)$ ，表示接下来有 $t$ 组测试数据。<br>　　每组数据第一行，给出两个正整数 $n, k (1\le k\le n\le 10^4)$ ，表示数组的长度与划分的目标段数。<br>　　如果你要进行询问，请输出 “? x y” ，其中 $x$ 代表询问的左界， $y$ 代表目标 $f$ 值。若存在一个最小的 $r$ 使得 $f(x, r) &#x3D; y$ ，则会在输入缓冲区给出这个值。若不存在，则在输入缓冲区给出 $n + 1$ 的值。<br>　　如果你要确定答案，请输出 “! m” ，其中 $m$ 代表你在该组数据中提交的答案。<br>　　请注意，在确定答案后，如果答案正确，则会在输入缓冲区给出 “1” ，否则给出 “-1” 。即使你能够保证你的答案一定正确，也请一定要从输入缓冲区中读取这个反馈数据，以免在接收下一组数据时造成影响。如果你答案错误，或者提问超出了次数，都会得到 “-1” ，此时请主动结束程序从而节约时间（因为程序最终一定会给出Wrong Answer）。<br>　　数据保证，并未向用户给出的数组 $A_n$ 所有元素值皆为 $[1, n] 范围内的正整数$ 。同时，所有组的 $n$ 总和不超过 $10^4$ 。</p><h3 id="测试用例-2"><a href="#测试用例-2" class="headerlink" title="测试用例"></a>测试用例</h3><p>　　有 3 组测试数据，数组分别为 $[1]\quad [1, 2] \quad [1, 3, 6, 1, 2, 1]$。输入输出如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs TEXT">input :3<br>input :1 1<br>output:! 1<br>input :1<br>input :2 2<br>output:? 1 1<br>input :1<br>output:? 2 1<br>input :3<br>output:! -1<br>input :1<br>input :6 3<br>output:? 1 9<br>input :7<br>output:? 1 6<br>input :2<br>output:? 3 6<br>input :3<br>output:? 4 6<br>input :6<br>output:! 6<br>input :1<br></code></pre></td></tr></table></figure><h3 id="解题思路（官方）"><a href="#解题思路（官方）" class="headerlink" title="解题思路（官方）"></a>解题思路（官方）</h3><p>　　根据题目的性质，我们可以推出以下结论：<br>　　① 数组的最大值 $M$ 我们可以通过至多 $n$ 次询问得到。<br>　　② 若存在合法答案 $m$ ，则 $m$ 必能被 $M$ 整除。<br>　　③ 若存在合法答案 $m$ ，则 $m$ 一定在 $M, 2M, … , nM$ 之间。<br>　　④ 数组合法地分为 $k$ 段后，每段的宽度一定都不小于 $\frac{m}{M}$ 。<br>　　⑤ 于是有 $k * \frac{m}{M} \le n \Rightarrow m \le \frac{nM}{k}$ ，由于 $m$ 必然能被 $M$ 整除且为整数，因此该式子可以转换为 $m \le \lfloor \frac{n}{k} \rfloor * M$。<br>　　其中，① 可以通过以下方法实现：由于数组中的元素都在 $[1, n]$ 的范围内，因此我们可以用 $n$ 次询问机会来依次枚举最大值 $M$ 。假设最大值为 $M$ 时，则必有 $f(1, n) &#x3D; nM$，因此可以依次询问”? 1 n*i”，当返回的结果为 $n$ 时，代表当前的 $i$ 为最大值。<br>　　当数组的最大值为 $M$ 时，那么它至少在数组出现一次。假设存在合法划分答案，则它必然会被划分到某个子段中，于是该子段的 $f(l,r) &#x3D; M * (r - l + 1)$ &#x3D; m ，因此 $m$ 必然能被 $M$ 整除，因此 ② 成立。<br>　　由于数组长度为 $n$ ，$f(l, r)$ 的最大值为 $f(1, n) &#x3D; nM$ ，而 $m$ 又能被 $M$ 整除，因此 $m$ 一定是 $M$ 的整数倍，且不超过 $nM$ ，因此 ③ 成立。<br>　　当划分后的某个子段中包含了最大值 $M$ 时，则该子段的宽度一定是最小的，或者说，不存在其他的比它宽度还小的子段。而该子段的宽度为 $\frac{m}{M}$ ，因此所有子段的宽度都不小于该值，④ 成立。<br>　　由于每个子段的宽度都不小于 $\frac{m}{M}$ ，且所有子段宽度之和为 $n$ ，于是有 $k * \frac{m}{M} \le n$，⑤ 成立。<br>　　由于 $m \le \lfloor \frac{n}{k} \rfloor * M$，我们可以从该值依次往下递减 $M$ 来枚举 $m$ 的取值，对于每个取值，至多只需要 $k$ 次询问就能得知该取值是否合法。我们最初通过 “? 1 m”得到 $r_1$ ，再通过 “? $r_1$ m” 得到 $r_2$ ，以此类推，若在 $k$ 次询问之后，成功得到了 $n$ ，则代表当前的 $m$ 是合法答案。若当前的 $m$ 不是合法答案，则会在中途的某次询问中，得到 $n+1$ ，结束询问即可，$m$ 的所有可能取值都验证完毕之后，消耗的询问次数一定不会超过 $k * \lfloor \frac{n}{k} \rfloor$ 次。再加上为获取数组最大值所用掉的 $n$ 次，总共也不会超过 $2n$ 次。</p><p>官方原文如下：<br>Let’s denote maximum value in array a as $mx$. Since the element with maximum value will belong to some segment，then if m exists, m will be divisible by $mx$. Obviously, $m$ can’t be greater than $n ⋅ mx$, so now the candidates for value of $m$ are $mx, 2 ⋅ mx, 3 ⋅ mx, … , n ⋅ mx$.</p><p>To find the value of mx we can query “? 1 n⋅i” for each $1\le i \le n$ and $mx$ will be equal to such $i$, querying which will give $n$ as the answer.</p><p>We can check each of $n$ possible values in $k$ queries, but that wouldn’t fit in query limit.</p><p>Actually, since the length of each segment in partition will be greater than or equal to $\frac{m}{mx}$, and there are exactly $k$ segments, we can get a simple inequality $k ⋅ \frac{m}{mx} \le n$ (since sum of lengths of segments is exactly $n$),which means $m$ can not be greater than $mx ⋅ ⌊n&#x2F;k⌋$, so it is enough to check first $⌊n&#x2F;k⌋$ candidates for $m$ in $k$ queries each. Total number of queries used would be $n+k⋅⌊n&#x2F;k⌋$ which doesn’t exceed $2n$.</p><h3 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> GCC optimize(<span class="hljs-string">&quot;O3&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> GCC target(<span class="hljs-string">&quot;popcnt&quot;</span>)</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, k;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-type">int</span> max_value = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;? 1 &quot;</span> &lt;&lt; i * n &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        cout.<span class="hljs-built_in">flush</span>();<br>        <span class="hljs-type">int</span> r;<br>        cin &gt;&gt; r;<br>        <span class="hljs-keyword">if</span> (r == n)<br>        &#123;<br>            max_value = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> right = n / k * max_value;<br>    <span class="hljs-type">int</span> response;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> current = right; current; current -= max_value)<br>    &#123;<br>        <span class="hljs-type">bool</span> legal = <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; ++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (index &gt;= n)<br>            &#123;<br>                legal = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            cout &lt;&lt; <span class="hljs-string">&quot;? &quot;</span> &lt;&lt; index + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; current &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>            cout.<span class="hljs-built_in">flush</span>();<br>            cin &gt;&gt; index;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!legal || index != n)<br>        &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;! &quot;</span> &lt;&lt; current &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        cout.<span class="hljs-built_in">flush</span>();<br>        cin &gt;&gt; response;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;! -1&quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    cout.<span class="hljs-built_in">flush</span>();<br>    cin &gt;&gt; response;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios_base::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">1</span>;<br>    cin &gt;&gt; t;<br>    <span class="hljs-keyword">while</span> (t--)<br>    &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Codeforces</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>启动GTA Vice City时找不到640x480分辨率模式的解决方案</title>
    <link href="/2024/05/11/%E5%90%AF%E5%8A%A8GTA-Vice-City%E6%97%B6%E6%89%BE%E4%B8%8D%E5%88%B0640x480%E5%88%86%E8%BE%A8%E7%8E%87%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2024/05/11/%E5%90%AF%E5%8A%A8GTA-Vice-City%E6%97%B6%E6%89%BE%E4%B8%8D%E5%88%B0640x480%E5%88%86%E8%BE%A8%E7%8E%87%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>　　启动GTA VC（罪恶都市）时弹出报错窗口，显示cannot find 640x480 video mode。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h3><p>　　网络上查询得到的大部分都是这个解决方案，但是本人尝试后并没有解决问题。<br>　　先找到启动游戏的可执行文件，然后打开它的属性页面（通过右键菜单找到，Win11下Shift+右键可直接显示旧版本菜单）。<br><img src="/assets/images/2024-05-11/rightClickPage.png" alt="右键菜单示意图"><br>然后切换到兼容性，选中以兼容模式启动，并选择Windows XP（或者其他，都可以试试），并勾选下方的以640x480分辨率启动。<br><img src="/assets/images/2024-05-11/1.png" alt="兼容模式启动示意图"><br>　　不过这种方案对我的机子无效。</p><h3 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h3><p>　　在Bilibili上看到的，通过将配置有其他分辨率设置的配置文件放到特定目录来做到让它以其他分辨率启动游戏。Github上就有现成的配置文件可以下载，比如 <a href="https://github.com/jeandudey/gta-vc-settings-rs/blob/master/tests/gta_vc.set">GTA VC配置文件</a>，也可以 <a href="../../../../assets/web/tools/download_file.html?filename=gta_vc.set">点击此处</a> 直接下载。需要存放的目录是 [C:\Users\[你的用户名]\Documents\GTA Vice City User Files] ，放进去后就可以正常启动了。</p>]]></content>
    
    
    <categories>
      
      <category>游戏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024-02-14随笔</title>
    <link href="/2024/02/14/2024-02-14%E9%9A%8F%E7%AC%94/"/>
    <url>/2024/02/14/2024-02-14%E9%9A%8F%E7%AC%94/</url>
    
    <content type="html"><![CDATA[<p>寒假规则怪谈：</p><ol><li>亲戚来访时如果父母在家，那么需要礼貌地进行打招呼，如遇到不认识的亲戚，需要主动询问。</li><li>吃饭时可以不主动说话，但是当亲戚与你谈话且父母在一旁观测时，你不能敷衍地回答，要表现出热情。</li><li>无论能不能喝酒，都尽可能不要喝酒。</li><li>亲戚们吃饭时，如果能够提前离开餐桌，请立马出门逛街！除非有紧急事件或者到达洗漱上床休息的时间否则千万不要回来！</li><li>尽可能在凌晨4点前入睡，保证至少有3个小时的睡眠时长。</li></ol>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 924 (Div.2)</title>
    <link href="/2024/02/14/Codeforces-Round-924-Div-2/"/>
    <url>/2024/02/14/Codeforces-Round-924-Div-2/</url>
    
    <content type="html"><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://codeforces.com/contest/1928">Codeforces Round 924 (Div.2)</a></p><hr><h2 id="Problem-A-Rectangle-Cutting"><a href="#Problem-A-Rectangle-Cutting" class="headerlink" title="Problem A: Rectangle Cutting"></a>Problem A: Rectangle Cutting</h2><ul><li>时间限制：1秒</li><li>内存限制：256 MB</li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>　　给定一个长和宽都是整数的长方形，你可以尝试将它们先分割为两个边长都是整数的小长方形再组合成一个不同的长方形。注意，2×1 的长方形和 1×2 的长方形我们认为是同样的长方形，因为它们彼此的长和宽都分别相等，因此一个 1×2 的长方形你无法分割重组出新的长方形。现在给出长方形的长和宽，请问你是否能够分割重组出新的长方形？</p><ul><li><p>输入描述<br>　　第一行，一个正整数 $t(1 \le t \le 10^4)$ ，表示接下来有 $t$ 组数据。<br>　　接下来 $t$ 行，每行具有两个整数 $a,b(1\le a,b \le 10^9)$，表示当前这组数据给出的长方形的两条相邻边的长度（并不保证哪条一定更长）。</p></li><li><p>输出描述<br>　　对于每组数据，如果能组成新的长方形，那么输出一行“Yes”，否则输出一行“No”。</p></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>　　由于分割后的长方形需要重新组合，那么它们至少要有一条边长度是一致的，所以一定是选取偶数长度的边从中间进行分割才有机会组合出新的长方形。那么如果给出的长方形边长都是奇数，必然无法实现目标。而如果都是偶数，那么必然可以实现目标。而如果只有一方是偶数，并且偶数方是奇数方的两倍，那么无法组合出新的长方形。</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="comment">// 如果两条边都是奇数，那么没法分割成整数边的两个小长方形</span></span><br><span class="line">    <span class="keyword">if</span> (a % <span class="number">2</span> &amp;&amp; b % <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果两条边都是偶数，那么必然可以分割重组为新长方形</span></span><br><span class="line">    <span class="keyword">if</span> (a % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; b % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当只有一边是偶数时，如果偶数边的长度是奇数边的两倍，那么无法组合成新长方形</span></span><br><span class="line">    <span class="keyword">if</span> ((a % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; a == <span class="number">2</span> * b) || (b % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; b == <span class="number">2</span> * a))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-B-Equalize"><a href="#Problem-B-Equalize" class="headerlink" title="Problem B: Equalize"></a>Problem B: Equalize</h2><ul><li>时间限制：1秒</li><li>内存限制：256 MB</li></ul><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>　　给定一个长度为 $n$ 的数组 $a_1,a_2,…,a_n$，你可以执行一次以下操作：</p><ol><li>设计一个长度为 $n$ 的排列 $p_1,p_2,…,p_n$，所谓排列就是一个长度为 $n$ 的数组，其中的 $1,2,…,n$ 这 $n$ 个数各出现 $1$ 次。例如 $[1,2,3]$ 和 $[2,1,3]$都是长度为 $3$ 的排列，而 $[1,2,2]$ 不是。</li><li>将排列的元素值依次加到相应位置的素组元素中。即：对于所有的 $i&#x3D;1,2,…,n$， 令 $a_i &#x3D; a_i + p_i$。</li></ol><p>　　问：在执行这样一次操作之后，最多能有多少个元素的数值会是一样的？</p><ul><li><p>输入描述<br>　　第一行，一个正整数 $t (1\le t\le 2*10^4)$，表示接下来有 $t$ 组数据。<br>　　每组数据具有两行，第一行，一个正整数 $n (1\le n \le 2 * 10^5)$，表示给出的数列的长度。<br>　　第二行， $n$ 个整数，表示数列 $a_1,a_2,…,a_n (1\le a_i \le 10^9)$。<br>　　数据保证对于所有组的 $n$ 总和不超过 $2*10^5$。</p></li><li><p>输出描述<br>　　每组数据输出一行，每行一个整数，表示等值元素的最大可能个数。</p></li></ul><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>　　我们必然要将一个排列的值加入到数组中，在将排列和数组都进行升序排序的情况下，排列是公差为 $1$ 的等差数列，最好的情况就是数组本身也是一个公差为 $1$ 的等差数列，这样可以让排列反过来恰好补齐。当然，数列可能也不会这么工整，可能是 $[1,1,2,3,3,4,7]$ 这样的，我们先计算它的差分数组（所谓差分数组就是记录该元素与上一个元素的差值，首元素没有上一个元素，直接取0）得到 $C&#x3D;[0,0,1,1,0,1,3]$，我们的排列可以用来填补这些差值，比如 $C_i &#x3D; 1$ 意味着这个元素和上个元素相差 $1$ ，我们可以分别放 $2,1$ 来补全差值。但是如果 $C_i &#x3D; 0$，那么反而无法让它们保持相等。<br>　　要解决题目的问题，我们就要利用排列去消除差分数组中尽可能长的一段连续区间内的数。首先，为什么要是连续的区间？对于数组 $[1,2,100,150,151]$，它的差分数组是 $[0,1,98,50,1]$，其中有两个 $1$，但是如果只是消去这两个 $1$，中间的没有消去，那么这两个位置只是和相邻的上一个元素相等，彼此之间没有相等。而如果数组足够长，以至于你有足够多的排列元素可以让排序后的数组中不相邻的元素相等，那么你完全可以选择让中间的元素和前面的那个元素相等，这样花费的代价只会更低。<br>　　那么现在，排列的长度 $n$ 就可以视作为用于填补差值的剩余值，随着填补它会剩余越来越少。假设有差分数组 $C&#x3D;[0,1,2,3,100,1,2,3]$ ，此时 $n&#x3D;8$ ，我填补 $C_2&#x3D;1$时，需要令 $p_1$ 为一个较大的数，然后 $p_2$ 比它小 $1$ ，比如 $p_1 &#x3D; 8,p_2&#x3D;7$，然后我要填补 $C_3&#x3D;2$，我的 $p_3$ 又要比 $p_2$ 小 $2$ ，于是 $p_3&#x3D;5$ ，以此类推， $p_4&#x3D;2$， $C_5$ 就已经无法被填补了。那么不难发现，如果刚好够用的情况下，我们总共能够填补 $n-1$ 的数值，因为排列的最大值和最小值相差 $n-1$ 。<br>　　所以如果一个区间 $[L,R]$ 内的 $C_i$ 总和不超过 $n-1$ ，那么我们就有机会让里面的 $C_i \neq 0$ 所对应的元素相等。而里面起初 $C_i&#x3D;0$ 的元素只能舍弃，无法保持相等。我们可以采用 <a href="https://oi-wiki.org/misc/two-pointer/">双指针</a> 算法来维护我们的最终答案。当发现一个区间 $[L,R]$ 的 $C_i$ 总和没有超过 $n-1$ 时，我们统计其区间内部原本的 $C_i&#x3D;0$ 的元素个数，记为 $Z$ ，那么更行答案 $ans &#x3D; \max(ans,L-R+1-Z + 1)$。这里最后为什么又加 $1$ 呢，因为前面只是计算填了多少个坑，让后面的元素值等于参照元素值，参照元素也要统计进去。</p><h3 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[i] = arr[i] - arr[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> zero = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// [l ,r)</span></span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (r &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tot &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, r - l - zero + <span class="number">1</span>);</span><br><span class="line">            tot += arr[r];</span><br><span class="line">            <span class="keyword">if</span> (arr[r] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                zero++;</span><br><span class="line">            &#125;</span><br><span class="line">            r++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tot -= arr[l];</span><br><span class="line">        <span class="keyword">if</span> (arr[l] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            zero--;</span><br><span class="line">        &#125;</span><br><span class="line">        l++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tot &lt; n)&#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, r - l - zero + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-C-Physical-Education-Lesson"><a href="#Problem-C-Physical-Education-Lesson" class="headerlink" title="Problem C: Physical Education Lesson"></a>Problem C: Physical Education Lesson</h2><ul><li>时间限制：1秒</li><li>内存限制：256 MB</li></ul><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>　　现在有这样的一个填数规则，给定一个大于 $1$ 的正整数 $k$ ，数列从首项开始往后填的值依次为 $1,2,…,k,k-1,…,2,1,2,…k,…$ 。当 $k&#x3D;2$ 时，数列为 $1,2,1,2$ ，当 $k&#x3D;3$ 时，数列为 $1,2,3,2,1,2,3,…$。不难发现，这样的数列每经过 $2k-2$ 个元素之后会开始新一轮循环。<br>　　现在给定一个正整数 $n$ 和 正整数 $x$，数据保证 $x &lt; n$，请问 $k$ 有多少种取值可以使得填数后的数列第 $n$ 个位置上的值是 $x$ ？</p><ul><li>输入描述<br>　　第一行，一个正整数 $t(1\le t\le 100)$，表示接下来有 $t$ 组数据。<br>　　接下来 $t$ 行，每一行包含两个正整数 $n,x(1\le x &lt; n\le 10^9)$。</li><li>输出描述<br>　　对于每组数据，输出一行，每行一个整数，表示 $k$ 的合法取值个数。</li></ul><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>　　循环部分的长度是 $2k-2$ ，循环中元素的值是先增大再减小（ $k&#x3D;2$ 时除外）。如果所求的位置 $n$ 处于增大过程中，那么就是当前循环中的第 $x$ 个元素。于是有 $n \bmod{(2k-2)} &#x3D; x$ （式1），其中 $ \bmod $ 表示取模运算，即取余数，$5 \bmod 3 &#x3D; 2$。同理，如果 $n$ 处于减小过程中，那么就是当前循环的第 $k + (k-1) - (x) + 1 &#x3D; 2k-x$ 个元素（当 $k&gt;2$ 时有效），于是有 $n \bmod (2k-2) &#x3D; 2k-x$ （式2）。<br>　　根据式1，可以得到：<br>$$<br>\begin{aligned}<br>&amp; n &#x3D; \lambda (2k-2) + x \quad (其中 \lambda 是待定的正整数)\\<br>\\<br>\Rightarrow \quad &amp; k &#x3D; \frac{n-x}{2 \lambda} + 1 \quad<br>\end{aligned}<br>$$<br>　　我们可以尝试不同的 $\lambda$ 值，如果得出的 $k$ 是大于1的正整数，并且它不小于 $x$ (因为 $k &lt; x$ 时，数列根本不会出现 $x$ 这个值)，那么该 $k$ 值就可以计入答案。而实际上，从另一个角度考虑，我们并不是要逐个尝试 $\lambda$ 的值，而是去找 $n-x$ 的偶数因子，找到它的所有偶数因子，也就代表找到了 $\lambda$ 。寻找一个数 $v$ 因子有一种时间复杂度 $O(\sqrt{v})$ 的算法。当我们找到一对整数 $a,b$ 满足 $a*b&#x3D;n-x$ 时，如果 $a$ 是偶数且 $b + 1 \ge x$，那么 $b + 1$ 就可以作为一个有效的 $k$ 值计入统计。如果 $b$ 是偶数且 $a+1 \ge x$，那么也将$a+1$计入统计。<br>　　同样地，根据式2，可以得到：<br>$$<br>\begin{aligned}<br>&amp; n &#x3D; \lambda (2k-2) + (2k - x) \quad (其中 \lambda 是待定的非负整数)\\<br>\\<br>\Rightarrow \quad &amp; k &#x3D; \frac{n+x-2}{2(\lambda + 1)} + 1<br>\end{aligned}<br>$$<br>　　注，这里为什么 $\lambda$ 可以取 $0$ 而上面的不行，因为题目数据限制 $x &lt; n$，因此必不可能处于第一个循环的上升阶段，但是可能处于第一个循环的下降阶段。然后和之前的方法一样，找 $n+x-2$的偶数因子然后计入统计（这里还要满足算出来的 $k$ 大于 $2$），两个式子计入的统计要进行去重处理，因为它们可能得出同样的 $k$ 值。最后看看一共有多少个 $k$ 值被统计，就得到答案了。</p><h3 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">set&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"><span class="type">int</span> n, x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将val除以其偶数因子之后能得到的值放入ans(如果其结果大于x-1)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calculate</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (val &amp; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> right = <span class="built_in">sqrt</span>(val);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= right; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (val % i != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> tmp = val / i;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; tmp &gt;= x - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">insert</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmp % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; i &gt;= x - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">insert</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> &gt;= x - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ans.<span class="built_in">clear</span>();</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; x;</span><br><span class="line">    <span class="keyword">if</span> ((n - x) % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;0\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">calculate</span>(n - x);</span><br><span class="line">    <span class="built_in">calculate</span>(n + x - <span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-D-Lonely-Mountain-Dungeons"><a href="#Problem-D-Lonely-Mountain-Dungeons" class="headerlink" title="Problem D: Lonely Mountain Dungeons"></a>Problem D: Lonely Mountain Dungeons</h2><ul><li>时间限制：1秒</li><li>内存限制：256 MB</li></ul><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>　　有许多不同种族的人员来组成军队，他们会被分为多支队伍，被分配到不同的队伍且属于同一种族的每一对成员都会使整体的战斗力增加 $b$ ，如果一共有 $k$ 支队伍，那么整体的战斗力要扣除 $(k-1) * x$ 。队伍的数量至少为 $1$ ，请问，在给定 $n$ 个种族以及每个种族的人员数量以及 $b,x$ 的值时，能够得到的最大整体战斗力是多少？</p><ul><li>输入描述<br>　　第一行，一个正整数 $t(1\le t \le 2* 10 ^ 4)$ 表示接下来有 $t$ 组数据。<br>　　每一组数据第一行，三个整数 $n,b,x(1\le n\le 2*10^5,1\le b\le 10^6,0\le x\le 10^9)$ ，分别表示种族个数、上文中的贡献值基数以及分队的惩罚值基数。<br>　　每一组数据第二行， $n$ 个正整数 $c_1,c_2,…,c_n(1\le c_i \le 2*10^5)$ ，分别表示 $n$ 个种族各自的成员数量。<br>　　数据保证 $c_1+c_2+…+c_n$ 不超过 $2*10^5$。</li><li>输出描述<br>　　对于每组测试数据，输出一行，包含一个整数，表示整体能达到的最大战斗力。</li></ul><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>　　整体战斗力由两个部分组成，一个是队员所产生的贡献，一个是分队所造成的惩罚。分得队伍越多整体扣除掉的战斗力就越多（当 $x \neq 0$ 时），那么惩罚部分自然是随着队伍数量增加而单调下降的（以对总体的贡献来看，因此取负值）。而队员所产生的贡献必然是随着队伍增加而增加，最好的情况就是所有人都单独成为一支队伍，不会存在同族人员分配到同一队伍的情况，这样队员所产生的贡献就最大化了。贡献+惩罚，一个上升一个下降，惩罚函数是线性函数，贡献函数不好分析，我解题时只是盲猜一手函数整体最复杂的情况下导函数也只是单调变化的，具体没有去验证。导函数单调的情况下整体战斗力曲线可能会是先上升后下降或者先下降后上升，也可能是一直上升或者一直下降，对于这四种情况都可以用三分法来快速缩小最值点范围，从而很快能够得到最大值。<br>　　决定采用三分法之后，接下来就是如何计算这两个部分的值了，当将其分为 $k$ 队时有：<br>$$<br>\begin{aligned}<br>&amp; A &#x3D; -(k-1)*x\\<br>\\<br>&amp; B &#x3D; \sum_{i&#x3D;1}^{n}{[\frac{k*\alpha * (k-1) * \alpha}{2} + (k-1) * \alpha * \beta + \frac{\beta *(\beta - 1)}{2}]} * b \\<br>\\<br>&amp; (其中 \alpha &#x3D; \lfloor \frac{c_i}{k} \rfloor, \beta &#x3D; c_i \bmod k)\\<br>\\<br>&amp; \text{Result} &#x3D; A + B<br>\end{aligned}<br>$$<br>　　然后采用三分法计算出 Result 可能的最大结果即可。</p><h3 id="解题代码-3"><a href="#解题代码-3" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, b, x;</span><br><span class="line"><span class="type">int</span> c[<span class="number">200005</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当分成k队时的总战斗力</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">calculate</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> alpha = c[i] / k;</span><br><span class="line">        <span class="type">int</span> beta = c[i] % k;</span><br><span class="line">        tot += ((<span class="type">long</span> <span class="type">long</span>)alpha * (k - <span class="number">1</span>) * alpha * k / <span class="number">2</span> + (<span class="type">long</span> <span class="type">long</span>)(k - <span class="number">1</span>) * alpha * beta + (<span class="type">long</span> <span class="type">long</span>)beta * (beta - <span class="number">1</span>) / <span class="number">2</span>) * b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tot - (<span class="type">long</span> <span class="type">long</span>)(k - <span class="number">1</span>) * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; b &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 三分法</span></span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">200000</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l + <span class="number">3</span> &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> m1 = l + (r - l) / <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> m2 = m1 + (r - l) / <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> tmp1 = <span class="built_in">calculate</span>(m1);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> tmp2 = <span class="built_in">calculate</span>(m2);</span><br><span class="line">        <span class="keyword">if</span> (tmp1 &gt; tmp2)</span><br><span class="line">        &#123;</span><br><span class="line">            r = m2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            l = m1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, <span class="built_in">calculate</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Codeforces</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 906 (Div.2)</title>
    <link href="/2023/11/03/Codeforces-Round-906-Div-2/"/>
    <url>/2023/11/03/Codeforces-Round-906-Div-2/</url>
    
    <content type="html"><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://codeforces.com/contest/1890">Codeforces Round 906 (Div.2)</a></p><hr><h2 id="Problem-A-Doremy’s-Paint-3"><a href="#Problem-A-Doremy’s-Paint-3" class="headerlink" title="Problem A: Doremy’s Paint 3"></a>Problem A: Doremy’s Paint 3</h2><ul><li>时间限制：1秒</li><li>内存限制：256 MB</li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>　　本题定义一种数组是“好数组”，只要该数组满足某条件：对于数组中的任意两个相邻的元素之和都会得到同一个结果。更数学化一点的描述就是：$$\forall i \forall j (i,j \in [1, n-1] \cap \mathbb{Z}) \rightarrow a_i + a_{i+1} &#x3D; a_j + a_{j+1}$$ 其中 $\mathbb{Z}$ 是整数域。<br>　　现在给定一个长度为 $n$ 的数组 $A_n$ ，你可以将它任意排序，问是否能够将它变为“好数组”，如果能，输出“YES”，否则输出“NO”。</p><ul><li>输入描述<br>　　第一行，一个正整数 $t$ ，表示接下来有 $t (1\le t\le 100)$ 组数据。<br>　　对于每组数据，第一行，一个正整数 $n (2 \le n \le 1000)$ ，表示数组的长度。<br>　　第二行， $n$ 个整数，表示数组 $a_1,a_2,…,a_n(1\le a_i \le 10^5)$。</li><li>输出描述<br>　　对于每组数据，输出一行“YES”或“NO”。</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>　　很容易得出，“好数组”的各元素要么都是同一个值，要么是两个不同的值交替出现。可以考虑统计一下有多少个数出现，出现的次数是多少，简单判断一下就可以了。</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">100001</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        cin &gt;&gt; val;</span><br><span class="line">        count[val]++;</span><br><span class="line">        nums.<span class="built_in">insert</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span> ||</span><br><span class="line">        (nums.<span class="built_in">size</span>() == <span class="number">2</span> &amp;&amp; <span class="built_in">abs</span>(count[*nums.<span class="built_in">begin</span>()] - count[*(--nums.<span class="built_in">end</span>())]) &lt;= <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Problem-B-Qingshan-Loves-Strings"><a href="#Problem-B-Qingshan-Loves-Strings" class="headerlink" title="Problem B: Qingshan Loves Strings"></a>Problem B: Qingshan Loves Strings</h2><ul><li>时间限制：1秒</li><li>内存限制：256 MB</li></ul><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>　　本题中定义一个字符串是“好字符串”，如果该字符串满足：不存在两个相同且位置上相邻的字符。现给定两个仅由’0’和’1’组成的字符串 $S,T$ ，由于它不一定是一个“好字符串”，因此你可以将字符串 $T$ 插入到 $S$ 的任意位置从而得到新的 $S$ ，而这样的操作你可以执行任意次(也可以不执行)。问：是否有可能让 $S$ 成为“好字符串”？如果可能，输出“YES”，否则输出“NO”。</p><ul><li><p>输入描述<br>　　第一行，一个正整数 $t$ ，表示接下来有 $t(1\le t \le 2000)$ 组数据。<br>　　对于每组数据，第一行，两个正整数 $n,m(1\le n,m \le 50)$ ，分别表示字符串 $S,T$ 的长度。<br>　　第二行，一个长度为 $n$ 的字符串 $S$ ，数据保证该字符串仅由’0’,’1’组成。<br>　　第三行，一个长度为 $m$ 的字符串 $T$ ，数据保证该字符串仅由’0’,’1’组成。</p></li><li><p>输出描述<br>　　对于每组数据，输出一行“YES”或一行“NO”。</p></li></ul><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>　　如果 $s$ 最初就已经是“好字符串”了，那么就可以直接输出“YES”。如若不然，判断一下 $T$ 是否是“好字符串”，如果不是，那么无论操作多少次，都会存在一个完整的 $T$ 在 $S$ 内部，那么无论如何也构造不出“好字符串”。如果是，那么就需要考虑它的两头(当然，也有可能它就只有一个字符)，如果最左边是’0’，最右边也是’0’ (下文简写为 (L, R) )，那么可以解决 $S$ 中的 “11” 部分，(‘0’,’1’) 按理可以插入到 “10” 当中，但是 “10” 并不需要被解决，它不会违反“好字符串”的规定。总之，固定不变的两个头决定了 $T$ 只能解决四种情况中的一种。简单判断一下 $S$ 中是否存在超出了 $T$ 所能解决的范围的连续字符就行了。</p><h3 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    string s, t;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">    <span class="type">bool</span> ans = <span class="literal">true</span>;</span><br><span class="line">    set&lt;string&gt; types;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; s.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[i + <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            ans = <span class="literal">false</span>;</span><br><span class="line">            string tmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            tmp += s[i];</span><br><span class="line">            tmp += s[i + <span class="number">1</span>];</span><br><span class="line">            types.<span class="built_in">insert</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; t.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (t[i] == t[i + <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string type = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    type += t[<span class="number">0</span>];</span><br><span class="line">    type += t[t.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (types.<span class="built_in">size</span>() &gt; <span class="number">1</span> || type[<span class="number">0</span>] != type[<span class="number">1</span>] || types.<span class="built_in">find</span>(type) != types.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Problem-C-Qingshan-Loves-Strings-2"><a href="#Problem-C-Qingshan-Loves-Strings-2" class="headerlink" title="Problem C: Qingshan Loves Strings 2"></a>Problem C: Qingshan Loves Strings 2</h2><ul><li>时间限制：1秒</li><li>空间限制：256 MB</li></ul><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>　　本题中定义一个字符串是“好字符串”，如果该字符串 $S$ 满足(假设其长度是 $n$ )：<br>$$<br>\forall i (i \in [1, n]\cap \mathbb{Z}) \rightarrow S_{i} &#x3D; S_{n-i+1}<br>$$ 其中 $\mathbb{Z}$ 是整数域。<br>　　现给定一个仅由’0’和’1’组成的字符串 $S$ ，你可以执行某种操作0~300次：将“01”插入到字符串 $S$ 的任意位置，得到新的 $S$ 。问：是否有可能在经过若干次(或0次)操作之后让 $S$ 成为“好字符串”？如果不可能，那么输出“-1”，否则输出你给出的插入位置。</p><ul><li><p>输入描述<br>　　第一行，一个正整数 $t(1\le t\le 100)$ ，表示接下来有 $t$ 组数据。<br>　　对于每组数据，第一行，一个正整数 $n(1\le n\le 100)$ ，表示字符串的长度。<br>　　第二行，一个长度为 $n$ 的字符串 $S$ ，仅由’0’和’1’组成。</p></li><li><p>输出描述<br>　　对于每组数据，如果不存在能够构造出“好字符串”的可能性，那么只输出“-1”。<br>　　否则在该组数据的第一行输出一个正整数 $P$ ，表示你要进行插入操作的次数(应满足 $0\le P\le 300$)。<br>　　然后在第二行输出 $P$ 个非负整数，表示依次插入的位置。如果 $P&#x3D;0$ ，那么该行为空行。<br>　　注意，当进行第 $i$ 次插入时，插入的位置是相对于前 $i-1$ 次插入完成之后的字符串而言的。如果插入位置 $P_i &#x3D; 0$ ，那么表示插入到开头，否则表示插入到当前的 $S$ 的第 $P_i$ 个字符之后。</p></li></ul><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>　　这道题的解法我想得不知道偏到哪个地方去了，这里就放一下官方的题解吧。<br>　　First, there is no solution when the number of 0’s and 1’s are different.<br>　　Otherwise, the construction follows:<br>if $s_1 \neq s_n$ now, we can ignore $s_1$ and $s_n$ , and consider $s_{2…n-1}$ as a new $s$ . If $s$ is empty, the algorithm ends.<br>　　Now $s_1 &#x3D; s_n$ . If they are $1$ , insert $01$ to the front; otherwise , insert $01$ to the end. Look at this example:<br>　1. “$110010$”<br>　2. “$1001$”<br>　3. “$\underline{01}1001$”<br>　4. “$1100$”<br>　5. “$10$”<br>　6. “”<br>　　This operation is actually equivalent to moving the last $1$ to the front or moving the first $0$ to the end. For example, in step 2 to 4 above, we succeed moving the last $1$ to the front. So in the worst case, every character in the string are moved, and we need $n$ moves.<br>　　Actually, we don’t need $n$ moves but $n&#x2F;2$ moves. Because for the $0$ and $1$ deleted in the same operation, at most one of them need to be moved.</p><h3 id="解题代码-官方"><a href="#解题代码-官方" class="headerlink" title="解题代码(官方)"></a>解题代码(官方)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// By Imakf</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ok</span><span class="params">(std::string s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">length</span>(); ++i)</span><br><span class="line">    <span class="keyword">if</span> (s[i] == s[i - <span class="number">1</span>])</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">std::string s;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n; std::cin &gt;&gt; n;</span><br><span class="line">  std::cin &gt;&gt; s;</span><br><span class="line">  <span class="type">int</span> cnt0 = <span class="number">0</span>, cnt1 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">    cnt0 += s[i] == <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    cnt1 += s[i] == <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (cnt0 != cnt1) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="number">-1</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; z;</span><br><span class="line">  std::deque&lt;<span class="type">char</span>&gt; q;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); ++i)</span><br><span class="line">    q.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> d = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (q.<span class="built_in">front</span>() == q.<span class="built_in">back</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (q.<span class="built_in">front</span>() == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">        q.<span class="built_in">push_back</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        q.<span class="built_in">push_back</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        z.<span class="built_in">push_back</span>(n - d);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        q.<span class="built_in">push_front</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        q.<span class="built_in">push_front</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        z.<span class="built_in">push_back</span>(<span class="number">0</span> + d);</span><br><span class="line">      &#125;</span><br><span class="line">      n += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; q.<span class="built_in">front</span>() != q.<span class="built_in">back</span>()) &#123;</span><br><span class="line">      q.<span class="built_in">pop_back</span>();</span><br><span class="line">      q.<span class="built_in">pop_front</span>();</span><br><span class="line">      ++d;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; z.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; z.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    std::cout &lt;&lt; z[i];</span><br><span class="line">    <span class="keyword">if</span> (i + <span class="number">1</span> == z.<span class="built_in">size</span>()) std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span> std::cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> t;</span><br><span class="line">  std::cin &gt;&gt; t;</span><br><span class="line">  <span class="keyword">while</span> (t--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Codeforces</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵快速幂算法</title>
    <link href="/2023/11/03/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%AE%97%E6%B3%95/"/>
    <url>/2023/11/03/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="矩阵快速幂的介绍"><a href="#矩阵快速幂的介绍" class="headerlink" title="矩阵快速幂的介绍"></a>矩阵快速幂的介绍</h3><p>　　先说说和矩阵快速幂在思想上一致的快速幂算法：对于计算函数 $\displaystyle F(x)&#x3D;a^{x}$ 的某个函数值，我们不必让计算机去进行 $x$ 次乘法，而是可以通过将其拆解为两个相同的部分的乘积(也就是某个数的平方)，从而减少不必要的计算。比如要计算 $2^8$ 的值，完全没有必要通过 $2*2*2*…*2$ 依次得出 $2^1,2^2,2^3,…,2^8$的值。而是可以转换为 $(((2^1)^2)^2)^2$ ，与前者不同的是，后者进行平方运算时只需要知道 $2^1,2^2,2^4,2^8$ 这少数的几个值。不难看出，快速幂算法快就快在它避免了不必要的计算，将一个表达式尽可能拆解为两个相同的数的积，当得到了其中一方的值时就不需要再去计算另一方了。如果无法拆解，那么在这一层当中可以单独抽离出一份来做乘法，比如 $2^9$ 可以写为 $(2^4)^2 * 2^1$。<br>　　同样的，对于矩阵的幂运算，也可以用这样的方式来进行优化，当然，前提是这个矩阵的行列条件可以执行幂运算。如果你还不清楚什么是矩阵，矩阵如何做运算，那么可以先去了解一点线性代数相关的内容。<br>　　在平时遇到的算法题当中，需要用到快速幂的地方通常一眼就能够看出来，毕竟很多题你看一看就意识到哪里要进行幂运算了。但是矩阵快速幂则有点不同，虽然二者思想一致，实现起来也都不算难，但是没有一定经验的人或许根本就看不出来某个地方居然还可以用矩阵来运算，更不用提矩阵快速幂了。<br>　　因此我个人认为，要在算法中利用到矩阵快速幂，关键点并不在于算法本身，而是你能否将一个问题转换为矩阵的幂运算的问题。</p><h3 id="经典例子——斐波那契数列"><a href="#经典例子——斐波那契数列" class="headerlink" title="经典例子——斐波那契数列"></a>经典例子——斐波那契数列</h3><p>　　斐波那契数列就是前两项为 $1$ ，从第 $3$ 项开始的任意第 $i$ 项的值都等于 第 $i-1$ 和第 $i-2$ 项之和的数列。由于前两项是固定值，那么后面的所有项其实也都是固定值。当然，某些题目中可能会让前两项变为其他的值，不过我们现在要谈论的东西不会因为前两项是什么值而受到影响，我们要关注的只是它这个 <strong>“从第三项开始的每一项都等于前两项之和”</strong>的特性。<br>　　假设现在有这样一个编程问题，给定一个具有斐波那契数列性质的数列 $A &#x3D; a_1,a_2,a_3…$ ，不过 $a_1$ 和 $a_2$ 的值不会在题目中就告诉你，而是在程序执行后输入到程序中。那么，你如何设计程序得到某个指定位置的项 $a_n$ (这个 $n$ 也是在输入中给出)的值？<br>　　当这个 $n$ 不会很大时，完全可以开一个足够大的数组，然后把前两项的值写进去，剩余的项依次推导得到，直到计算得到第 $n$ 项的值。如果再有一点节省内存的意识，完全可以只开几个变量来存储需要用到的前 $2$ 项和待计算项，就不用开个这么大的数组了。<br>　　但是，有的时候问题会比这个还更加刁钻，会给出一个比较大的 $n$ (可能达到 $10^{18}$ 这个数量级)，并且还要求你能够在数秒之内给出结果，不过，由于答案很大，这样的题目一般会让我们对结果的数值对一个数取余数。取余数的目的是让我们不用花心思在“如何存储一个超出了基本变量所能存储的最大值的数”这样的问题上，毕竟高精度计算不是这道题考察的重点。回到题目本身，如果依然使用递推的方式来一项一项地推导，根据当前计算机的算力，是没办法在数秒之内给出结果的(本句话写于2023年)。因此，需要一些手段来更快地计算出结果，这个手段正是矩阵快速幂。这题看上去只看得到它有计算，看不出来哪里有矩阵，不过它确实可以通过构造出矩阵来进行计算得到相同的效果。<br>我们构造这样一个矩阵 $T$ ：</p><p>$$<br>\begin{bmatrix}<br>1 &amp; 1\\<br>1 &amp; 0<br>\end{bmatrix}<br>$$</p><p>再拿目前已经知道的前两项 $a_1, a_2$ 构造出另一个矩阵 $B$ ：</p><p>$$<br>\begin{bmatrix}<br>a_2\\<br>a_1<br>\end{bmatrix}<br>$$</p><p>然后我们让它们两个相乘(注意矩阵乘法的两方不能交换位置)：</p><p>$$<br>\begin{bmatrix}<br>1 &amp; 1\\<br>1 &amp; 0<br>\end{bmatrix}<br>\begin{bmatrix}<br>a_2\\<br>a_1<br>\end{bmatrix}<br>\text{&#x3D;}<br>\begin{bmatrix}<br>a_1+a_2\\<br>a_2<br>\end{bmatrix}<br>\Rightarrow<br>\begin{bmatrix}<br>a_3\\<br>a_2<br>\end{bmatrix}<br>$$</p><p>这样，我们就得出了 $a_3$ 的值，同样的，如果我们要得到 $a_4$ 的值，就只需要再左乘一次矩阵 $T$ 即可。如果我们希望计算到 $a_n$ ，就是用矩阵 $B$ 左乘 $n-2$ 次矩阵 $T$ ，也就是 $T^{n-2} B$ 。如果止步于此，那么这只会是个比之前的递推还要更复杂且费时间的算法，但是现在它已经符合了矩阵快速幂的条件，我们可以用矩阵快速幂来加快计算 $T^{n-2}$ 过程，得到结果之后再去右乘矩阵 $B$ ，就得出了 $a_n$ 的值。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>矩阵快速幂</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2023-10-29随笔</title>
    <link href="/2023/10/29/2023-10-29%E9%9A%8F%E7%AC%94/"/>
    <url>/2023/10/29/2023-10-29%E9%9A%8F%E7%AC%94/</url>
    
    <content type="html"><![CDATA[<h2 id="数学练习题"><a href="#数学练习题" class="headerlink" title="数学练习题"></a>数学练习题</h2><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><p>计算不定积分：<br>$$<br>\int{x^3}·\ln{x}·\mathrm{d}x<br>$$<br>解：<br>根据分部积分法有：<br>$$<br>\begin{aligned}<br>u·v &amp;&#x3D; \int{u·\mathrm{d}v} + \int{v·\mathrm{d}u}\\<br>    &amp;&#x3D; \int{u·\frac{\mathrm{d}v}{\mathrm{d}x} · \mathrm{d}x} + \int{v·\frac{\mathrm{d}u}{\mathrm{d}x}·\mathrm{d}x} \\<br>\end{aligned}<br>$$<br>其中$u$和$v$是两个以$x$为自变量，且在定义域内有连续导数的函数。<br>令$u&#x3D;\frac{1}{4}x^4$，$v&#x3D;\ln{x}$，则有:<br>$$<br>\begin{aligned}<br>\frac{\mathrm{d}u}{\mathrm{d}x} &amp;&#x3D; x^3\\<br>\mathrm{d}u &amp;&#x3D; x^3\mathrm{d}x\\<br>v·\mathrm{d}u &amp;&#x3D; \ln{x}·x^3\mathrm{d}x\<br>\end{aligned}<br>$$<br>则有：$\displaystyle \int{v·\mathrm{d}u}$与原积分表达式吻合。故而有：<br>$$<br>\begin{aligned}<br>\int{x^3·\ln{x}·\mathrm{d}x} &amp;&#x3D; u·v - \int{u·\mathrm{d}v}\\<br>&amp;&#x3D; u·v - \int{u·\frac{\mathrm{d}v}{\mathrm{d}x}·\mathrm{d}x}\\<br>&amp;&#x3D; \frac{1}{4}x^4 · \ln{x} - \int{\frac{1}{4}x^4 · \frac{1}{x} · \mathrm{d}x}\\<br>&amp;&#x3D; \frac{1}{4}x^4 · \ln{x} - \int{\frac{1}{4}x^3 · \mathrm{d}x}\\<br>&amp;&#x3D; \frac{1}{4}x^4 · \ln{x} - \frac{1}{16}x^4 + C<br>\end{aligned}<br>$$<br>其中$C$为常数。</p><hr><h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><p>计算不定积分：<br>$$<br>\int{x·\cos(6x)·\mathrm{d}x}<br>$$<br>解：<br>同样采用分部积分法，令:<br>$$<br>\begin{cases}<br>u &#x3D; x\<br>v &#x3D; \frac{1}{6}·\sin(6x)<br>\end{cases}<br>$$<br>有：<br>$$<br>\int{u·\mathrm{d}v} &#x3D; \int{x·\cos(6x)·\mathrm{d}x}<br>$$<br>则：<br>$$<br>\begin{aligned}<br>\int{x·\cos(6x)·\mathrm{d}x} &amp;&#x3D; u·v - \int{\frac{1}{6}·\sin(6x)·\mathrm{d}x}\\<br>                    &amp;&#x3D; \frac{1}{6}x·\sin(6x) + \frac{1}{36}\cos(6x) + C<br>\end{aligned}<br>$$</p><hr><h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><p>计算不定积分：<br>$$<br>\int \arctan{(\sqrt{x})}·\mathrm{d}x\\<br>$$<br>解：<br>令：<br>$$<br>\begin{cases}<br>u &amp;&#x3D; x\\<br>v &amp;&#x3D; \arctan{(\sqrt{x})}<br>\end{cases}<br>$$<br>则：<br>$$<br>\begin{aligned}<br>\int \arctan{(\sqrt{x})}·\mathrm{d}x &amp;&#x3D; u·v - \int u·\mathrm{d}v\\<br>                                     &amp;&#x3D; x·\arctan{(\sqrt{x})} - \int \frac{x}{2\sqrt{x}·(1+x)}\mathrm{d}x\\<br>                                     &amp;&#x3D; x·\arctan{(\sqrt{x})} - \int \frac{\sqrt{x}}{2(1+x)}\mathrm{d}x<br>\end{aligned}<br>$$<br>针对积分式：<br>$$<br>\int \frac{\sqrt{x}}{2(1+x)}\mathrm{d}x<br>$$<br>令：$\displaystyle u&#x3D;\sqrt{x}$，则有：<br>$$<br>\begin{aligned}<br>\frac{\mathrm{d}u}{\mathrm{d}x} &amp;&#x3D; \frac{1}{2\sqrt{x}}\\<br>\Rightarrow \quad \mathrm{d}x &amp;&#x3D; 2\sqrt{x}·\mathrm{d}u<br>\end{aligned}<br>$$<br>则：<br>$$<br>\begin{aligned}<br>\int \frac{\sqrt{x}}{2(1+x)}\mathrm{d}x &amp;&#x3D; \int \frac{\sqrt{x}}{2(1+x)}·2\sqrt{x}·\mathrm{d}u\\<br>                                        &amp;&#x3D; \int \frac{x}{1+x}·\mathrm{d}u\\<br>                                        &amp;&#x3D; \int \frac{x+1-1}{1+x}·\mathrm{d}u\\<br>                                        &amp;&#x3D; \int (1 - \frac{1}{1+x})·\mathrm{d}u\\<br>                                        &amp;&#x3D; \int \mathrm{d}u - \int \frac{1}{1+x}·\mathrm{d}u\\<br>                                        &amp;&#x3D; \int \mathrm{d}u - \int \frac{1}{1+u^2}·\mathrm{d}u\\<br>                                        &amp;&#x3D; u - \arctan{u} + C_{1}\\<br>                                        &amp;&#x3D; \sqrt{x} - \arctan{\sqrt{x}} + C_1\\<br>\end{aligned}<br>$$<br>则最初的原积分式：<br>$$<br>\begin{aligned}<br>\int \arctan{\sqrt{x}}·\mathrm{d}x &amp;&#x3D; x·\arctan{\sqrt{x}} - \sqrt{x} + \arctan{\sqrt{x}} + C\\<br>                                   &amp;&#x3D; (x+1)\arctan{\sqrt{x}} - \sqrt{x} + C<br>\end{aligned}<br>$$<br>其中$C$和$C_1$是常数，之所以用下标区分它们只是为了体现它们不是同一个常数，毕竟前面的正负号没有在计算过程中变号。</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微积分</tag>
      
      <tag>分部积分法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 905 (Div.2)</title>
    <link href="/2023/10/26/Codeforces-Round-905-Div-2/"/>
    <url>/2023/10/26/Codeforces-Round-905-Div-2/</url>
    
    <content type="html"><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://codeforces.com/contest/1888">Codeforces Round 905 (Div.2)</a></p><hr><h2 id="Problem-A-Chemistry"><a href="#Problem-A-Chemistry" class="headerlink" title="Problem A: Chemistry"></a>Problem A: Chemistry</h2><ul><li>时间限制: 2秒</li><li>内存限制: 256MB</li></ul><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>　　给定一个长度为$n$的仅由小写字母组成的字符串$S$，你需要删除$k$个字符，但是删除哪些字符由你决定，删除完$k$个字符之后剩余的字符你可以随意排列，请问你是否有机会得到一个回文串，即：存在一种删除方案和一种排列方案使得最终的字符串$T’&#x3D;t_{1}t_{2}…t_{n-k}$满足：$t_1&#x3D;t_{n-k}$ , $t_2&#x3D;t_{n-k-1}$，…</p><ul><li><p>输入描述<br>　　第一行，一个正整数$t(1 \le t \le 10^{4} )$，表示接下来有$t$组数据。<br>　　接下来每组数据的第一行，正整数$n$和$k$ $(0\le k &lt; n \le 10^5)$，分别表示字符串的长度$n$和要删除的字符个数$k$。<br>　　第二行，一个长度为$n$的字符串。<br>　　输入数据满足：$t$组数据的所有$n$的值总和不超过$2*10^5$。</p></li><li><p>输出描述<br>　　对于每一组数据，如果存在相应方案，则输出一行“YES”，否则输出一行“NO”。</p></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>　　回文串的长度如果是偶数，那么任意字符都出现偶数次，如果是奇数，那么会恰好有一个字符出现奇数次。题目给出了n和k，那么最终串的长度的奇偶是可以确定的。<br>　　如果是偶数，那么我删除掉$k$个字符之后剩下字符的种类出现的次数应该都是偶数才能排成回文串。如果在我删掉之前，出现次数是奇数的字符种数的奇偶性和k的奇偶性一致,并且这个种数不大于k，那么就可以让最终剩下的都出现偶数次，反之则必然出现奇数次的，所以这种情况下希望它们一致。<br>　　如果是奇数，则希望它们不一致。当然，同样需要种数不大于k+1（这里+1是因为可以保留1个奇数次，就不需要动它了）。根据以上思路，想要解决这题就很简单了。</p><h3 id="解题代码-C"><a href="#解题代码-C" class="headerlink" title="解题代码(C++)"></a>解题代码(C++)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 此处处理一组独立数据 */</span></span><br><span class="line">        <span class="type">int</span> n, k;</span><br><span class="line">        <span class="type">int</span> count[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : s)</span><br><span class="line">        &#123;</span><br><span class="line">            count[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> oddCount = <span class="number">0</span>; <span class="comment">// 出现奇数次的种数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; ++c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (count[c] % <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                oddCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> ans = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">/* 可以构造的条件1：最终长度偶数，oddCount和k奇偶一致 */</span></span><br><span class="line">        <span class="keyword">if</span> ((n - k) % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; (oddCount % <span class="number">2</span>) == (k % <span class="number">2</span>) &amp;&amp; oddCount &lt;= k)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 可以构造的条件2：最终长度奇数，oddCount和k奇偶不一致 */</span></span><br><span class="line">        <span class="keyword">if</span> ((n - k) % <span class="number">2</span> &amp;&amp; (oddCount % <span class="number">2</span>) != (k % <span class="number">2</span>) &amp;&amp; oddCount &lt;= k + <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Problem-B-Raspberries"><a href="#Problem-B-Raspberries" class="headerlink" title="Problem B: Raspberries"></a>Problem B: Raspberries</h2><ul><li>时间限制：2秒</li><li>内存限制：256 MB</li></ul><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>　　给定一个长度为$n$的数组$A &#x3D; a_1,a_2,…,a_n$和一个正整数$k(2 \le k \le 5)$，你可以对数组执行以下操作若干次：<br>　　选取一个下标$i(1\le i \le n)$，令$a_i &#x3D; a_i + 1$。<br>　　问：至少需要执行多少次操作才能使得数组所有元素的乘积能够被$k$整除？</p><ul><li><p>输入描述<br>　　第一行，一个正整数$t(1 \le t \le 10^4)$，表示接下来有$t$组数据。<br>　　每组数据第一行，正整数$n,k(2 \le n \le 10^5, 2\le k \le 5)$，分别表示数组$A$的长度和除数$k$。<br>　　第二行，$n$个整数，分别表示$a_1,a_2,…,a_n( 1 \le a_i \le 10)$。<br>　　输入数据满足：$t$组数据的所有$n$的值总和不超过$2*10^5$。</p></li><li><p>输出描述<br>　　对于每组数据，输出一个整数，表示你认为所需要的最少操作次数。</p></li></ul><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>　　$k$的范围很小，感觉可能是分类讨论，$k&#x3D;2$时很好判断，就看数列里有没有偶数就可以了，有就0次，没有就1次。$k&#x3D;3$时也很好判断，就是判断数列中哪个数离它下一个3的倍数最近，这个最近的距离就是答案。$k&#x3D;5$时也很简单，同样是看离下一个5的倍数最近的那个距离，事实上，只要是质数，就可以按这样的方法处理。$k&#x3D;4$呢？如果数列里已经有4的倍数了那就0次，除此之外，如果有1个2的倍数，那就需要再构建出一个2的倍数，只需要1次。如果有两个2的倍数，那么也是0，如果一个都没有，一种方案是构建4的倍数，一种方案是构建两个2的倍数，两种都计算一下次数取最小值就行。好像就这几种情况，分类讨论就可以了，然后把可以合并的情况给合并一下，减少无用代码。</p><h3 id="解题代码-C-1"><a href="#解题代码-C-1" class="headerlink" title="解题代码(C++)"></a>解题代码(C++)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> min(a, b) ((a) &lt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, (k - (arr[i] % k)) % k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, <span class="number">2</span> - <span class="built_in">min</span>(<span class="number">2</span>, count));</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Problem-C-You-Are-So-Beautiful"><a href="#Problem-C-You-Are-So-Beautiful" class="headerlink" title="Problem C: You Are So Beautiful"></a>Problem C: You Are So Beautiful</h2><ul><li>时间限制：1秒</li><li>内存限制：256 MB</li></ul><hr><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>　　给定一个长度为$n$的数组$A&#x3D;a_1,a_2,…,a_n$，问该数组有多少个非空子数组是唯一存在而且在原数组位置上连续的？例如数组$[1,1,3,5,7]$，可以选中其中的第$1,3,5$个元素构成子数组$[1,3,7]$，但是它不是唯一存在的，因为我选取第$2,3,5$个元素也能构成一样的结果。而子数组$[3,5,7]$就是唯一存在且连续的，而若选取第$2,3,4$个元素得到$[1,3,5]$虽然连续，但是不唯一存在。</p><ul><li><p>输入描述<br>　　第一行，一个正整数$t(1\le t \le 10^4)$，表示接下来有$t$组测试数据。<br>　　对于每组数据的第一行，一个正整数$n(1\le n \le 10^5)$，表示数组的长度。<br>　　第二行，$n$个正整数，表示$a_1,a_2,…,a_n(1\le a_i \le 10^9)$。<br>　　输入数据满足：$t$组数据的所有$n$的值总和不超过$2*10^5$。</p></li><li><p>输出描述<br>　　对于每组数据，输出一个整数，表示你认为的符合条件的子数组的数量。</p></li></ul><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>　　假设一个连续的子数组$[a_i,a_{i+1},…,a_j]$是符合条件的，那么$a_i$的左边一定不会再有$a_i$出现了，同样的，$a_j$右边也不会再有$a_j$出现。我可以先统计一下每个元素出现的最左边的位置和最右边的位置，每个最左的位置和每个最右的位置相组合得到的区间$[L,R]$对应的连续子数组一定是唯一的！并且不会落下任何合法的子数组。<br>　　因此，我们可以借助C++的map来维护元素的最左位置和最右位置。再把它们汇总成两个数组，不需要知道这个位置上是哪个元素，只需要知道这个位置本身就行。然后将$L,R$两个数组按大小排个序，然后枚举一方，再通过二分法计算另一方的能够组成合法区间的分界位置（选取$L$中的元素作为左边界，$R$中的作为右边界，而左边界总不能在右边界的右边），从而计数。这样最终时间复杂度是$O(n*\log_2{n})$的，可以通过本题。</p><h3 id="解题代码-C-2"><a href="#解题代码-C-2" class="headerlink" title="解题代码(C++)"></a>解题代码(C++)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> min(a, b) ((a) &lt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; minIndex, maxIndex;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; L, R;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">        maxIndex[arr[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        minIndex[arr[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[u, v] : minIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        L.<span class="built_in">push_back</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[u, v] : maxIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        R.<span class="built_in">push_back</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(L.<span class="built_in">begin</span>(), L.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(R.<span class="built_in">begin</span>(), R.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>; <span class="comment">//不开long long见祖宗</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> l : L)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> iter = <span class="built_in">lower_bound</span>(R.<span class="built_in">begin</span>(), R.<span class="built_in">end</span>(), l);</span><br><span class="line">        ans += R.<span class="built_in">end</span>() - iter;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Problem-D1-Dances-Easy-version"><a href="#Problem-D1-Dances-Easy-version" class="headerlink" title="Problem D1: Dances (Easy version)"></a>Problem D1: Dances (Easy version)</h2><ul><li>时间限制：3秒</li><li>内存限制：256 MB</li></ul><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>　　给定两个长度为$n$的数组$A,B$，现在有这样一个问题：你可以先各自将两个数组任意排列，然后在数列非空的前提下，你可以从$A,B$中各自删去一个任意位置上的数从$A$中删除的元素所在位置和$B$删除的位置不需要相同，然后剩下的元素会形成新的数组，这样的操作你可以执行任意次。最少需要执行多少次才能使得最终的数组满足：如果还存在$k$个元素，那么对于所有的$i \in [1,k] \cap \mathbb{Z}$，有：$a_i &lt; b_i$，其中$\mathbb{Z}$代表整数域。<br>　　上述问题并不是你需要解决的最终问题，你需要解决的最终问题是：在给定上述的两个长度为$n$的数组的情况下，再给定一个正整数$m$。问，在数组$A$的首位元素$a_1$分别变为$1,2,…,m$的$m$种情况下，它们对应的上述问题的答案的总和是多少？<br>　　本题为简单版本，$m$的值恒定为$1$。在困难版本中，$m$的取值范围是$1\le m \le 10^9$。</p><ul><li><p>输入描述<br>　　第一行，一个正整数$t$，表示接下来有$t$组测试数据。<br>　　每组测试数据的第一行，正整数$n,m(2 \le n \le 10^5, m &#x3D; 1)$，分别表示两个数组的长度以及要处理的子问题个数。<br>　　第二行，$n-1$个整数，代表$a_2,a_3,…a_n(1 \le a_i \le 10^9)$，由于$a_1$的取值由$m$决定，因此此处不进行无意义的数据输入。<br>　　第三行，$n$个整数，代表$b_1,b_2,…,b_n(1 \le b_i \le 10^9)$。<br>　　输入数据满足：$t$组数据的所有$n$的值总和不超过$10^5$。</p></li><li><p>输出描述<br>　　对于每组测试数据，输出一个整数，表示该组数据的$m$个子问题答案的总和。</p></li></ul><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>　　没想出来（MD没注意到可以任意排序，想半天没想出来跟这个脱不了干系！），我去看了官方的题解。首先采用二分答案法，假定两数组各删去$k$个元素，判断在两数组都剩下$n-k$个元素的情况下是否可能存在合法的数组$A,B$满足题意。判断方式很简单，方法如下：将数组$A,B$升序排序，从$A$中删掉$k$个最大元素，从$B$中删掉$k$个最小元素，然后将最后剩下的元素配对比较一下看是否符合条件。<br>　　在困难版本下，$m$的取值范围是$1\le m \le 10^9$，由于改变的只会是$a_1$元素的值，它值的变化至多只会给问题的答案造成1的影响。比如，在$a_1$取值很小时，或许可以保留它的存在，而当它增大到越过某个临界点的时候，就需要将它删去，于是答案增加了1。可以通过二分法来找到这个临界点，从而得到两个范围$[1,k],[k+1,m]$，并计算一下其中一个范围时答案对应的值，比如$[1,k]$范围内需要删$x$次，那么$[k+1,m]$范围内就需要删除$x+1$次，于是最终答案就是$k*x + (m - k) * (x + 1)$。</p><h3 id="解题代码-简单版本-C"><a href="#解题代码-简单版本-C" class="headerlink" title="解题代码(简单版本, C++)"></a>解题代码(简单版本, C++)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> min(a, b) ((a) &lt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">200005</span>];</span><br><span class="line"><span class="type">int</span> b[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">sort</span>(b + <span class="number">1</span>, b + n + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 二分答案 求需要删除的最少次数</span></span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = n;</span><br><span class="line">    <span class="comment">// 假定删除k次时的校验函数</span></span><br><span class="line">    <span class="keyword">auto</span> check = [&amp;](<span class="type">int</span> k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - k; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt;= b[k + i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid))</span><br><span class="line">        &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; l &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解题代码-困难版本-C"><a href="#解题代码-困难版本-C" class="headerlink" title="解题代码(困难版本, C++)"></a>解题代码(困难版本, C++)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> min(a, b) ((a) &lt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> src_a[<span class="number">200005</span>];</span><br><span class="line"><span class="type">int</span> src_b[<span class="number">200005</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">200005</span>];</span><br><span class="line"><span class="type">int</span> b[<span class="number">200005</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> first)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(a, src_a, <span class="built_in">sizeof</span>(<span class="type">int</span>) * (n + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">memcpy</span>(b, src_b, <span class="built_in">sizeof</span>(<span class="type">int</span>) * (n + <span class="number">1</span>));</span><br><span class="line">    a[<span class="number">1</span>] = first;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">sort</span>(b + <span class="number">1</span>, b + n + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 二分答案 求需要删除的最少次数</span></span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = n;</span><br><span class="line">    <span class="comment">// 假定删除k次时的校验函数</span></span><br><span class="line">    <span class="keyword">auto</span> check = [&amp;](<span class="type">int</span> k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - k; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt;= b[k + i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid))</span><br><span class="line">        &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> m;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; src_a[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; src_b[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans_min = <span class="built_in">solve</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> ans_max = <span class="built_in">solve</span>(m);</span><br><span class="line">        <span class="keyword">if</span> (ans_min == ans_max)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; (<span class="type">long</span> <span class="type">long</span>)ans_min * m &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 最终的l和r都会等于能让答案+1的首元素取值的最小值 */</span></span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = m;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">solve</span>(mid) &gt; ans_min)</span><br><span class="line">            &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; (<span class="type">long</span> <span class="type">long</span>)ans_min * (l - <span class="number">1</span>) + (<span class="type">long</span> <span class="type">long</span>)ans_max * (m - l + <span class="number">1</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Problem-E-Time-Travel"><a href="#Problem-E-Time-Travel" class="headerlink" title="Problem E: Time Travel"></a>Problem E: Time Travel</h2><ul><li>时间限制：2秒</li><li>内存限制：512 MB</li></ul><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>　　现在有一个国家，内部有$n$个不同的地区，但是地区之间的交通道路并不总是可用的，只有在某几个特定的时间可以通行，而且道路是双向的。你有一台时光机，它可以让你穿梭于不同的时间。 但是它每次穿梭时间时到达的目标时间都是既定好的，你没法自主控制，不过你清楚地知道它穿梭的时间设定。在通过一条道路之后，时光机会自动执行一次，这意味着你无法在某个时间连续走完两条道路。现在给出地区的数量$n$，以及$t$个不同的特殊时间。对于每个特殊时间$t_i$，会给出一个可通行道路数量$m_i$和列表$[(u_1,v_1),(u_2,v_2),…,(u_{m_i},v_{m_i})]$。然后给出时光机可进行穿梭时间的次数$k$，以及这$k$次穿梭对应的目标时间$a_1,a_2,…,a_k$。你最初会在地区$1$，并且处于时间$a_1$。问：你最少需要经过多少次时间穿梭才能够到达区域$n$？（到达最终目标区域$n$之后时光机的自动执行不计入统计）</p><ul><li><p>输入描述<br>　　第一行，正整数 $n,t(2\le n\le 2*10^5,1\le t\le 2*10^5)$ 分别表示区域个数和特定时间个数。<br>　　接下来有 $t$ 组数据，第 $i$ 组数据的第一行，一个非负整数 $m_i(0 \le m_i \le \min(\frac{n(n-1)}{2}, 2*10^5))$ 代表在第 $i$ 个特定时间所能通行的道路数量。<br>　　第 $i$ 组数据的接下来$m_i$行，每行两个正整数 $u_j,v_j(1\le u_j,v_j\le n, u_j \neq v_j)$ ，代表一条道路所连接的两个区域。<br>　　接收完 $t$ 组时间点的道路数据之后，接下来一行，一个正整数 $k(1\le k \le 2*10^5)$ ，表示时光机可穿梭的次数。<br>　　接下来一行， $k$ 个正整数 $a_1,a_2,…,a_k(1\le a_i \le t)$ ，表示时光机每次穿梭后的时间点。<br>　　输入数据保证：所有的$m_i$总和不超过$2*10^5$。每个时间点对应的道路数据不会有重复（即使是 $(u,v)和(v,u)$ 也不会同时存在）。</p></li><li><p>输出描述<br>　　一个整数，表示从区域$1$到达区域$n$所需的最小穿梭次数，如果无法到达，那么输出$-1$。</p></li></ul><h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><p>　　Dijkstra最短路(堆优化版本)，需要维护数组 $D&#x3D;{d_1,d_2,…,d_n}$ ， $d_i$ 表示到达第 $i$ 个区域时最早可以是在第几次穿梭之后。需要维护所有的边可通行的时间列表，在再维护所有时间所在的穿梭轮次列表，这样在后面处理数据的时候就可以根据边得到这条边对应的可行穿梭轮次列表（列表会有多个），每个列表都要升序排序（数据输入的顺序就是升序的，存下来后不需要额外排序），后面需要用到二分查找。 $(u,v)和(v,u)$ 是同一条边，共用所有的数据即可。<br>　　然后就是基本的Dijkstra最短路算法，只不过在更新邻近点的$d_v$值时需要找到能够前往$v$的最早轮次。当前我们到达 $u$ 时最早可能处于 $d_u$ 次穿梭之后，枚举与$u$相连的所有边 $(u,v)$ ，对于每条边$(u,v)$：先获取允许它通行的时间列表 $[t_1,t_2,…t_x]$ ，枚举所有的 $t_i$ ，获取到其所在的穿梭轮次列表 $[idx_1,idx_2,…idx_y]$ ，这样你得到的列表就是允许该边通行的穿梭轮次列表之一，通过二分法找到在当前列表允许它通行的晚于当前轮次的最早轮次，然后维护多个列表的最小轮次，最终得到的就是需要的允许该边通行而且晚于当前轮次的最早轮次。假设得到 $y$ ，那么令 $d_v &#x3D; \min(d_v, y)$ ，就是假设等待到这个轮次之后前往 $v$ ，如果发现这样走能在更早的轮次到达，就更新数据，也就是Dijkstra的基本操作了。</p><h3 id="解题代码-C-3"><a href="#解题代码-C-3" class="headerlink" title="解题代码(C++)"></a>解题代码(C++)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> min(a, b) ((a) &lt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">200005</span>];</span><br><span class="line"><span class="type">int</span> dis[<span class="number">200005</span>];</span><br><span class="line">map&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;<span class="type">int</span>&gt;&gt; edgeTime; <span class="comment">/*边-&gt;可通行时间列表*/</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; timeIndex[<span class="number">200005</span>];             <span class="comment">/*时间-&gt;穿梭轮次列表*/</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; edge[<span class="number">200005</span>];                  <span class="comment">/*节点拥有的邻居列表*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, t;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= t; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> m;</span><br><span class="line">        cin &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u, v;</span><br><span class="line">            cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">            edge[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">            edge[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">            <span class="keyword">if</span> (u &gt; v)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(u, v);</span><br><span class="line">            &#125;</span><br><span class="line">            edgeTime[<span class="built_in">make_pair</span>(u, v)].<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> target;</span><br><span class="line">        cin &gt;&gt; target;</span><br><span class="line">        timeIndex[target].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        dis[i] = <span class="number">1e9</span>;</span><br><span class="line">        vis[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(dis[<span class="number">1</span>], <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> node = que.<span class="built_in">top</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (vis[node.second])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[node.second] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : edge[node.second])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u = node.second;</span><br><span class="line">            <span class="comment">// 当前节点u，目标节点v，需要边(u, v)</span></span><br><span class="line">            <span class="comment">// 需要找到让该边可通行的比现在晚的最早穿梭轮次（当前为node.first轮）</span></span><br><span class="line">            <span class="type">int</span> index = <span class="number">1e7</span>;</span><br><span class="line">            <span class="comment">// 遍历当前边可通行的时间列表（当前为node.first轮）</span></span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; &amp;passTimeList = edgeTime[<span class="built_in">make_pair</span>(<span class="built_in">min</span>(u, v), <span class="built_in">max</span>(u, v))];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> _time : passTimeList)</span><br><span class="line">            &#123;</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; &amp;vec = timeIndex[_time];</span><br><span class="line">                <span class="keyword">auto</span> iter = <span class="built_in">upper_bound</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), node.first);</span><br><span class="line">                <span class="keyword">if</span> (iter != vec.<span class="built_in">end</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    index = <span class="built_in">min</span>(index, *iter);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">1e7</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; dis[v])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = index;</span><br><span class="line">                que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(dis[v], v));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dis[n] == <span class="number">1e9</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; dis[n] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Codeforces</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2023-10-24随笔</title>
    <link href="/2023/10/24/2023-10-24%E9%9A%8F%E7%AC%94/"/>
    <url>/2023/10/24/2023-10-24%E9%9A%8F%E7%AC%94/</url>
    
    <content type="html"><![CDATA[<p>　　今天上午花了点时间写了牛客上的一道AC自动机的题，上次看到一篇讲AC自动机的文章之后只是花了些时间先去复习了KMP算法，然后写了KMP的题，AC自动机倒是没试过。不过算法思路大致记得，琢磨了一番终于正确敲出代码了。但是懒得发文章来讲解了，感觉意义不大，想学的人会找到更好的资料，不想学的不会来看的。我就把我的解题代码给贴出来吧。</p><hr><p>　　<a href="https://ac.nowcoder.com/acm/problem/20443">牛客-TJOI2013</a>，我的解法用到的知识点有：AC自动机、路径压缩。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string words[<span class="number">205</span>];</span><br><span class="line"><span class="type">int</span> wordsNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node *next[<span class="number">128</span>] = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    Node *fail = <span class="literal">nullptr</span>;</span><br><span class="line">    Node *father = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 被统计的次数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node *root = <span class="literal">nullptr</span>;</span><br><span class="line">unordered_map&lt;Node *, Node *&gt; last; <span class="comment">// Node通过fail递归查询得到的第一个具有flag的Node节点，初始状态应该指向其fail</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; wordsNum;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; wordsNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; words[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Start building AC automaton */</span></span><br><span class="line">    root = <span class="keyword">new</span> Node;</span><br><span class="line">    Node *ptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Build trie first */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; wordsNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr = root;</span><br><span class="line">        string &amp;str = words[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> &amp;c : str)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">nullptr</span> == ptr-&gt;next[c])</span><br><span class="line">            &#123;</span><br><span class="line">                ptr-&gt;next[c] = <span class="keyword">new</span> Node;</span><br><span class="line">                ptr-&gt;next[c]-&gt;father = ptr;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr = ptr-&gt;next[c];</span><br><span class="line">        &#125;</span><br><span class="line">        ptr-&gt;flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Now we can build AC automaton */</span></span><br><span class="line">    queue&lt;Node *&gt; que;</span><br><span class="line">    Node *tmp = <span class="literal">nullptr</span>;</span><br><span class="line">    que.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        ptr = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">128</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ptr-&gt;next[i])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            ptr-&gt;next[i]-&gt;fail = root;</span><br><span class="line">            tmp = ptr-&gt;fail;</span><br><span class="line">            <span class="keyword">while</span> (tmp)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (tmp-&gt;next[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    ptr-&gt;next[i]-&gt;fail = tmp-&gt;next[i];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    tmp = tmp-&gt;fail;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            que.<span class="built_in">push</span>(ptr-&gt;next[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        last[ptr] = ptr-&gt;fail;</span><br><span class="line">        <span class="comment">// printf(&quot;last[%p]=%p\n&quot;, ptr, last[ptr]);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">FindFlagNodeByFail</span><span class="params">(Node *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!ptr || !ptr-&gt;fail)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (last[ptr] &amp;&amp; last[ptr]-&gt;flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> last[ptr];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> last[ptr] = <span class="built_in">FindFlagNodeByFail</span>(last[ptr]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">GetNodeByWord</span><span class="params">(string &amp;str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *ptr = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> &amp;c : str)</span><br><span class="line">        ptr = ptr-&gt;next[c];</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    Node *ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    Node *tmp = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; wordsNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> &amp;c : words[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ptr-&gt;next[c])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr = ptr-&gt;next[c];</span><br><span class="line">            tmp = ptr;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// printf(&quot;tmp = %p\n&quot;, tmp);</span></span><br><span class="line">                <span class="keyword">if</span> (tmp-&gt;flag)</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp-&gt;count++;</span><br><span class="line">                    <span class="comment">// printf(&quot;i = %d, %p-&gt;count++\n&quot;, i, tmp);</span></span><br><span class="line">                &#125;</span><br><span class="line">                tmp = <span class="built_in">FindFlagNodeByFail</span>(tmp);</span><br><span class="line">            &#125; <span class="keyword">while</span> (tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; wordsNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Node *node = <span class="built_in">GetNodeByWord</span>(words[i]);</span><br><span class="line">        cout &lt;&lt; node-&gt;count &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>KMP算法</title>
    <link href="/2023/10/10/KMP%E7%AE%97%E6%B3%95/"/>
    <url>/2023/10/10/KMP%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="KMP算法介绍"><a href="#KMP算法介绍" class="headerlink" title="KMP算法介绍"></a>KMP算法介绍</h2><p>　　KMP算法是一种用于在一个源字符串 $S$ 中找目标字符串 $T$ 的所在位置的算法。相较于暴力匹配，它通过对目标字符串 $T$ 的结构进行分析，预先处理得到一些数据，从而能够在匹配过程中跳过大多无用的匹配操作，从而提高查找效率。<br>　　在暴力匹配中，目标字符串与源字符串相应位置匹配不上时，会将匹配的位置后移一位。比如在源字符串 $abcde$ 中试图找到 $cde$ 的位置，会先试图将 $S$ 中的 $abc$ 与 $cde$ 进行匹配。匹配失败后会将对齐的位置往后移动，变为 $bcd$ 来与 $cde$ 进行匹配。在源字符串和目标字符串都比较长时这种慢慢移动然后不断匹配的方法就会比较慢。因此KMP算法让它在匹配失败后不止移动一位，而是尽量多移动一些（具体移动多少取决于从目标串提取出的一些数据），从而提升一些效率。</p><h2 id="KMP算法的匹配位置移动原则"><a href="#KMP算法的匹配位置移动原则" class="headerlink" title="KMP算法的匹配位置移动原则"></a>KMP算法的匹配位置移动原则</h2><p>　　为了提升效率，匹配失败后自然是希望尽可能地多往后移动一些，从而多减少一些无用的匹配行为，也就是“不可能匹配成功”的匹配行为。但是也不能想当然地移动，不然可能错失能够正确匹配的位置。KMP算法中，给出的合适的移动距离与本次匹配时成功匹配的部分的最长公共前后缀长度有关。<br>　　让我们看以下的例子：<br>$$<br>\begin{cases}<br>S &#x3D; abxabxaby\\<br>T &#x3D; abxaby<br>\end{cases}<br>$$<br>　　当KMP算法试图在 $S$ 中寻找 $T$ 的所在位置时，会先将 $S$ 的 $abxabx$ 与 $abxaby$ 进行匹配：<br>$$<br>\begin{aligned}<br>&amp;S: &amp;abxabx\quad&amp;aby\\<br>&amp;T: &amp;abxaby\quad&amp;<br>\end{aligned}<br>$$<br>　　那么可以成功匹配的部分有 $abxab$ 。由于这个是匹配成功的部分，那么它自然会同时存在于$S$和$T$当中。不难观察到，$abxab$具有一个长度为$2$的公共前后缀 $ab$ ，于是KMP算法会将 $T$ 的位置进行适当地移动，让 $T$ 的前缀部分对齐到 $S$ 中相应的后缀部分：<br>$$<br>\begin{aligned}<br>&amp;S:\quad abx &amp;abxaby\\<br>&amp;T:\quad &amp;abxaby<br>\end{aligned}<br>$$<br>　　然后KMP算法会不断重复这个过程，直到整个 $T$ 都匹配成功(如果有需要，也可以让它继续匹配下去寻找多个所在位置)，或者移动到末尾仍然无法匹配。</p><h2 id="KMP算法的核心"><a href="#KMP算法的核心" class="headerlink" title="KMP算法的核心"></a>KMP算法的核心</h2><p>　　通过上面的例子不难看出，KMP算法它效率比较高的原因就是因为它通过匹配成功的部分的字符串的公共前后缀长度来得出它可以放心后移的距离，这个距离或许不一定是最大的，但是也足够用。如果你对 <strong>“为什么这样移动不会错过正确的位置”</strong> 感到疑惑，那么可以观察以下例子：<br>　　假设有源字符串 $S$ 和 $T$ ，其中 $x$ 不是指代字符’$x$’，只是为了体现长度而占位：<br>$$<br>\begin{cases}<br>S &#x3D; xxxxxxxxx\\<br>T &#x3D; xxxxxx<br>\end{cases}<br>$$<br>　　假设第一次匹配中，匹配成功的部分长度是 $5$ <strong>(假设1)</strong> ，并且其最长公共前后缀是 $2$ <strong>(假设2)</strong>，那么根据KMP算法，它会对齐到以下状态：<br>$$<br>\begin{aligned}<br>&amp;S:\quad xxx \quad&amp;xxxxxx\\<br>&amp;T: \quad&amp;xxxxxx<br>\end{aligned}<br>$$<br>　　同时，假设我们并不将 $T$ 往后移动 $3$ 位，而是只移动 $2$ 位，并且能够匹配成功整个 $T$ <strong>(假设3)</strong>：<br>$$<br>\begin{aligned}<br>&amp;S:\quad xx \quad&amp;xxxxxx&amp;\quad x\\<br>&amp;T: \quad&amp;xxxxxx&amp;<br>\end{aligned}<br>$$<br>　　那么，我们现在有以下信息(下标从 $1$ 开始表示)：<br>$$<br>\begin{aligned}<br>1.\quad S[1\sim 5] &#x3D; T[1\sim 5] \quad (假设1)\\<br>2.\quad S[3\sim 8] &#x3D; T[1\sim 6] \quad (假设3)<br>\end{aligned}<br>$$<br>　　可以得到：<br>$$<br>T[1\sim 3] &#x3D; S[3\sim 5] &#x3D; T[3\sim 5]<br>$$<br>　　于是， $T[1\sim 5]$ 存在一个长度为 $3$ 的公共前后缀，与假设 $2$ 矛盾(当然，这里取具体的数值是为了更直观一点，如果要严谨一点的证明应该使用一个变量来表示)。因此KMP算法的移动方式不会存在 <strong>“错过了正确位置”</strong> 的情况。<br>　　这个最长公共前后缀不是在匹配过程中得到匹配部分的串之后才去计算的，而是在匹配之前就先对目标串进行预处理，得到它的所有前缀相应的最长公共前后缀长度，毕竟能够匹配成功的部分一定是目标串的前缀。当然，本文中的最长公共前后缀不能包括串本身，不然所有串的最长公共前后缀都是它本身了。</p><h2 id="快速求解一个字符串的所有前缀的最长公共前后缀长度"><a href="#快速求解一个字符串的所有前缀的最长公共前后缀长度" class="headerlink" title="快速求解一个字符串的所有前缀的最长公共前后缀长度"></a>快速求解一个字符串的所有前缀的最长公共前后缀长度</h2><p>　　假设我们已经知道了一个字符串 $T[1\sim n]$ 的所有前缀的最长公共前后缀长度，但是我们要得到的数据不止如此，它后面还有其他的字符。那么我们把后面的一个字符加入进来，设新字符串为 $T[1\sim n+1]$ (第 $n+1$ 个字符就是新加进来的字符)，现在我们可以通过已有的数据快速计算出 $T[1\sim n+1]$ 的最长公共前后缀长度。<br>　　上面内容提到，我们已经知道了字符串 $T[1\sim n]$ 的所有前缀的最长公共前后缀长度，现在我们假定字符串 $T[1\sim n+1]$ 的最长公共前后缀长度为 $x$ ，然后现在加入了第 $n+1$ 个字符，如果这个字符和 $T[1\sim n+1]$ 的第 $x+1$ 个字符相同，那么 $T[1\sim n+1]$ 的最长公共前后缀就是 $x+1$ 。比如 $abcxabc$ ，最长公共前后缀是 $abc$ ，现在加入了一个字符 $x$ ，而它也恰好出现在前缀 $abc$ 的后面，那么最长公共前后缀的长度就增加了$1$ ，变成了 $abcx$ 。这种情况是很好判断的，也很容易理解。<br>　　最关键的是，如果这第 $n+1$ 个字符和第 $x+1$ 个字符并不相同，又该如何呢？我们观察这样一个字符串: $ababxabab$ ，它的最长公共前后缀是 $abab$ ，现在新加入一个字符 $a$ ，我们根据上面的内容发现它和第 $5$ 个位置的 $x$ 不一致，那么只能退而求其次，看看次长公共前后缀。对于字符串 $ababxabab$ ，它最长公共前后缀是 $abab$ ，它的次长公共前后缀是 $ab$ ，然后不难发现，加入新的字符 $a$ 之后它和第 $3$ 个位置的 $a$ 是一致的，所以新加入的字符 $a$ 虽然破坏了之前的最长公共前后缀，但是次长公共前后缀没有被破坏，长度加了 $1$ ，于是它晋升为了最长公共前后缀 ，字符串 $T[1\sim n+1]$ 的最长公共前后缀就是 $aba$ 。如果次长还是接不上这个字符呢？那就看次次长，直到没有公共前后缀了为止（这种情况，$T[1\sim n+1]$ 的最长公共前后缀就要变为空了）。<br>　　那么现在还有一个问题，我们之前有的数据是字符串 $T[1\sim n]$ 的所有前缀的最长公共前后缀长度，我们怎么知道次长公共前后缀的长度呢？观察刚才的字符串 $ababxabab$ ，最长是 $abab$ ，次长是 $ab$ 。而 $ab$ 又是 $abab$ 的最长公共前后缀。这不是巧合，而是特性，一个字符串的最长公共前后缀的最长公共前后缀就是次长公共前后缀。为什么呢？ $ababxabab$ 的最长公共前后缀是 $abab$ ，也就意味着它既出现在了开头位置，也出现在了末尾位置。如果要找一个次长的公共前后缀，那么一定也是出现在开头和末尾，也就是要找一个尽可能长的字符串，能够作为开头的 $abab$ 的前缀，又能够作为末尾的 $abab$ 的后缀，而又不能是串 $abab$ 本身。那这不就是要找 $abab$ 的最长公共前后缀吗！然后又因为我们早就知道了字符串 $T[1\sim n]$ 的所有前缀的最长公共前后缀长度， $abab$ 作为 $ababxabab$ 的一个前缀，我们早就知晓它的最长公共前后缀，直接取就可以了。<br>　　就这样，我们可以通过从1个字符开始，不断加入新的字符，不断得到这个越来越长的字符串的所有前缀的最长公共前后缀，直到整个目标串所有字符都被处理。然后就可以根据处理出来的这些数据在KMP算法中加速目标串的后移。</p><h2 id="代码示例（C-）"><a href="#代码示例（C-）" class="headerlink" title="代码示例（C++）"></a>代码示例（C++）</h2><p>　　现在有这样一个需求，通过控制台读入两个字符串，要找出第二个字符串在第一个字符串中出现的位置的首字母所在下标列表。比如在“abcabc”中找“abc”就会找到[0, 3]。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算字符串的所有前缀的最长公共前后缀长度，返回的数组中下标index表示的是前缀[0, index]对应的最长公共前后缀</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">CalculateCommon</span><span class="params">(string &amp;str)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ret</span><span class="params">(str.size())</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(str.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    ret[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; str.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            假设已处理的字符串：</span></span><br><span class="line"><span class="comment">            &quot;abcab&quot; 加入新字符 &#x27;c&#x27;  </span></span><br><span class="line"><span class="comment">            &quot;abcab&quot; 最长公共前后缀 &quot;ab&quot;，长度2，那么应该要将str[2]（对应的中间的&#x27;c&#x27;）和新加入的字符比较</span></span><br><span class="line"><span class="comment">            因此总是拿已处理的字符串最长公共前缀长度作为初始比较下标</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">int</span> compareIndex = ret[i<span class="number">-1</span>];</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            当跳出循环时，compareIndex要么是新的最长公共前后缀的前缀末尾下标，要么是-1，表示不存在公共前后缀</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == str[compareIndex])&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(compareIndex == <span class="number">0</span>)&#123;</span><br><span class="line">                compareIndex--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            compareIndex = ret[compareIndex<span class="number">-1</span>]; <span class="comment">//找次长公共前后缀 </span></span><br><span class="line">        &#125;</span><br><span class="line">        ret[i] = compareIndex + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从源字符串中找到目标字符串出现的所有位置</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">FindPosition</span><span class="params">(string &amp;src, string &amp;target)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">    <span class="comment">//计算所有前缀的最长公共前后缀</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; commonLength = <span class="built_in">CalculateCommon</span>(target);</span><br><span class="line">    <span class="comment">// offset 用于表示在匹配过程中目标串相对源串的位置偏移</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        abcabc</span></span><br><span class="line"><span class="comment">          cab  此时偏移量为2，匹配成功</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> offset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(offset + target.<span class="built_in">size</span>() &lt;= src.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="comment">//在当前偏移量情况下能否匹配成功</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;target.<span class="built_in">size</span>() &amp;&amp; target[i] == src[offset + i])&#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == target.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(offset); <span class="comment">//匹配成功</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//能够匹配的字符有 i 个，考虑应该偏移多少？</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            情况1：（能够匹配一些字符）</span></span><br><span class="line"><span class="comment">                [abcab]XXXXXX</span></span><br><span class="line"><span class="comment">                [abcab]Y    公共的length=2，应该偏移3，也就是 i - length</span></span><br><span class="line"><span class="comment">            =&gt;  变为</span></span><br><span class="line"><span class="comment">                abc[ab]XXXXXX</span></span><br><span class="line"><span class="comment">                   [ab]cabY</span></span><br><span class="line"><span class="comment">            情况2：（一点都匹配不上）</span></span><br><span class="line"><span class="comment">                abcde</span></span><br><span class="line"><span class="comment">                fg         公共的length=0，此时的 i=0，似乎是偏移2，也就是target的长度？</span></span><br><span class="line"><span class="comment">            =&gt;  变为</span></span><br><span class="line"><span class="comment">                abcde</span></span><br><span class="line"><span class="comment">                  fg</span></span><br><span class="line"><span class="comment">            情况3：</span></span><br><span class="line"><span class="comment">                abcdxabc</span></span><br><span class="line"><span class="comment">                cdx        和情况2类似，但是如果偏移3的话就会错过正确位置，偏移2应该是刚好，但是我觉得应该偏移1才通用（例如不是cdx而是bc，就只能偏移1）</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">            那么总结一下，对于有公共长度的就偏移 i - length，否则偏移1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">            offset += <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            offset += i - commonLength[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string src, target;</span><br><span class="line">    cin &gt;&gt; src &gt;&gt; target;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; indexes = <span class="built_in">FindPosition</span>(src, target);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;index: indexes)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;index: &quot;</span>&lt;&lt;index&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实战测试（交OJ题）"><a href="#实战测试（交OJ题）" class="headerlink" title="实战测试（交OJ题）"></a>实战测试（交OJ题）</h2><p>　　<a href="https://ac.nowcoder.com/acm/problem/13253">牛客——子串(NC13253)</a>，将上方代码稍作修改，再加上一点其他的内容就能够通过这道题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> digital[<span class="number">16</span>] = &#123;<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>,</span><br><span class="line">                          <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> finalStr[<span class="number">50005</span> * <span class="number">64</span>];</span><br><span class="line"><span class="type">int</span> strLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个整数转换为K进制数后贴到finalStr有效字符串的末尾</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NumToKBase</span><span class="params">(<span class="type">int</span> val, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">65</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(val == <span class="number">0</span>)&#123;</span><br><span class="line">        buffer[index] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        index += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(val &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        buffer[index] = digital[val % k];</span><br><span class="line">        val /= k;</span><br><span class="line">        index += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(index)&#123;</span><br><span class="line">        index -= <span class="number">1</span>;</span><br><span class="line">        finalStr[strLength] = buffer[index];</span><br><span class="line">        strLength += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    finalStr[strLength] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算字符串的所有前缀的最长公共前后缀长度，返回的数组中下标index表示的是前缀[0, index]对应的最长公共前后缀</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">CalculateCommon</span><span class="params">(string &amp;str)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ret</span><span class="params">(str.size())</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(str.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    ret[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; str.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="type">int</span> compareIndex = ret[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == str[compareIndex])&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(compareIndex == <span class="number">0</span>)&#123;</span><br><span class="line">                compareIndex--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            compareIndex = ret[compareIndex<span class="number">-1</span>]; <span class="comment">//找次长公共前后缀 </span></span><br><span class="line">        &#125;</span><br><span class="line">        ret[i] = compareIndex + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否能找到存在的位置</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">FindPosition</span><span class="params">(string &amp;src, string &amp;target)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; commonLength = <span class="built_in">CalculateCommon</span>(target);</span><br><span class="line">    <span class="type">int</span> offset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(offset + target.<span class="built_in">size</span>() &lt;= src.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;target.<span class="built_in">size</span>() &amp;&amp; target[i] == src[offset + i])&#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == target.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//匹配成功</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">            offset += <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            offset += i - commonLength[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    string target;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; target;</span><br><span class="line">    <span class="type">bool</span> exist = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">2</span>; k&lt;= <span class="number">16</span>; ++k)&#123;</span><br><span class="line">        strLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n; ++i)&#123;</span><br><span class="line">            <span class="built_in">NumToKBase</span>(i, k);</span><br><span class="line">        &#125;</span><br><span class="line">        string str = <span class="built_in">string</span>(finalStr);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">FindPosition</span>(str, target))&#123;</span><br><span class="line">            exist = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(exist)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;yes\n&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;no\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>KMP</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
